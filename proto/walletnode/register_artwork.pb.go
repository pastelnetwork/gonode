// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: walletnode/register_artwork.proto

package walletnode

import (
	bytes "bytes"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_sortkeys "github.com/gogo/protobuf/sortkeys"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type SessionRequest struct {
	IsPrimary bool `protobuf:"varint,1,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
}

func (m *SessionRequest) Reset()      { *m = SessionRequest{} }
func (*SessionRequest) ProtoMessage() {}
func (*SessionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{0}
}
func (m *SessionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionRequest.Merge(m, src)
}
func (m *SessionRequest) XXX_Size() int {
	return m.Size()
}
func (m *SessionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SessionRequest proto.InternalMessageInfo

func (m *SessionRequest) GetIsPrimary() bool {
	if m != nil {
		return m.IsPrimary
	}
	return false
}

type SessionReply struct {
	SessID string `protobuf:"bytes,1,opt,name=sessID,proto3" json:"sessID,omitempty"`
}

func (m *SessionReply) Reset()      { *m = SessionReply{} }
func (*SessionReply) ProtoMessage() {}
func (*SessionReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{1}
}
func (m *SessionReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionReply.Merge(m, src)
}
func (m *SessionReply) XXX_Size() int {
	return m.Size()
}
func (m *SessionReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionReply.DiscardUnknown(m)
}

var xxx_messageInfo_SessionReply proto.InternalMessageInfo

func (m *SessionReply) GetSessID() string {
	if m != nil {
		return m.SessID
	}
	return ""
}

type AcceptedNodesRequest struct {
}

func (m *AcceptedNodesRequest) Reset()      { *m = AcceptedNodesRequest{} }
func (*AcceptedNodesRequest) ProtoMessage() {}
func (*AcceptedNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{2}
}
func (m *AcceptedNodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptedNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptedNodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptedNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptedNodesRequest.Merge(m, src)
}
func (m *AcceptedNodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptedNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptedNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptedNodesRequest proto.InternalMessageInfo

type AcceptedNodesReply struct {
	Peers []*AcceptedNodesReply_Peer `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
}

func (m *AcceptedNodesReply) Reset()      { *m = AcceptedNodesReply{} }
func (*AcceptedNodesReply) ProtoMessage() {}
func (*AcceptedNodesReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{3}
}
func (m *AcceptedNodesReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptedNodesReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptedNodesReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptedNodesReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptedNodesReply.Merge(m, src)
}
func (m *AcceptedNodesReply) XXX_Size() int {
	return m.Size()
}
func (m *AcceptedNodesReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptedNodesReply.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptedNodesReply proto.InternalMessageInfo

func (m *AcceptedNodesReply) GetPeers() []*AcceptedNodesReply_Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type AcceptedNodesReply_Peer struct {
	NodeID string `protobuf:"bytes,1,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
}

func (m *AcceptedNodesReply_Peer) Reset()      { *m = AcceptedNodesReply_Peer{} }
func (*AcceptedNodesReply_Peer) ProtoMessage() {}
func (*AcceptedNodesReply_Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{3, 0}
}
func (m *AcceptedNodesReply_Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptedNodesReply_Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptedNodesReply_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptedNodesReply_Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptedNodesReply_Peer.Merge(m, src)
}
func (m *AcceptedNodesReply_Peer) XXX_Size() int {
	return m.Size()
}
func (m *AcceptedNodesReply_Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptedNodesReply_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptedNodesReply_Peer proto.InternalMessageInfo

func (m *AcceptedNodesReply_Peer) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

type ConnectToRequest struct {
	SessID string `protobuf:"bytes,1,opt,name=sessID,proto3" json:"sessID,omitempty"`
	NodeID string `protobuf:"bytes,2,opt,name=nodeID,proto3" json:"nodeID,omitempty"`
}

func (m *ConnectToRequest) Reset()      { *m = ConnectToRequest{} }
func (*ConnectToRequest) ProtoMessage() {}
func (*ConnectToRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{4}
}
func (m *ConnectToRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectToRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectToRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectToRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectToRequest.Merge(m, src)
}
func (m *ConnectToRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConnectToRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectToRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectToRequest proto.InternalMessageInfo

func (m *ConnectToRequest) GetSessID() string {
	if m != nil {
		return m.SessID
	}
	return ""
}

func (m *ConnectToRequest) GetNodeID() string {
	if m != nil {
		return m.NodeID
	}
	return ""
}

type ConnectToReply struct {
}

func (m *ConnectToReply) Reset()      { *m = ConnectToReply{} }
func (*ConnectToReply) ProtoMessage() {}
func (*ConnectToReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{5}
}
func (m *ConnectToReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectToReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectToReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectToReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectToReply.Merge(m, src)
}
func (m *ConnectToReply) XXX_Size() int {
	return m.Size()
}
func (m *ConnectToReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectToReply.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectToReply proto.InternalMessageInfo

type ProbeImageRequest struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *ProbeImageRequest) Reset()      { *m = ProbeImageRequest{} }
func (*ProbeImageRequest) ProtoMessage() {}
func (*ProbeImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{6}
}
func (m *ProbeImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProbeImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProbeImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProbeImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeImageRequest.Merge(m, src)
}
func (m *ProbeImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProbeImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeImageRequest proto.InternalMessageInfo

func (m *ProbeImageRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type ProbeImageReply struct {
	// version of dupde detection system
	DupeDetectionVersion string `protobuf:"bytes,1,opt,name=dupe_detection_version,json=dupeDetectionVersion,proto3" json:"dupe_detection_version,omitempty"`
	// hexstring of hash of candidate image
	HashOfCandidateImg                            string                                `protobuf:"bytes,2,opt,name=hash_of_candidate_img,json=hashOfCandidateImg,proto3" json:"hash_of_candidate_img,omitempty"`
	AverageRarenessScore                          float32                               `protobuf:"fixed32,3,opt,name=average_rareness_score,json=averageRarenessScore,proto3" json:"average_rareness_score,omitempty"`
	IsRareOnInternet                              bool                                  `protobuf:"varint,4,opt,name=is_rare_on_internet,json=isRareOnInternet,proto3" json:"is_rare_on_internet,omitempty"`
	MatchesFoundOnFirstPage                       uint32                                `protobuf:"varint,5,opt,name=matches_found_on_first_page,json=matchesFoundOnFirstPage,proto3" json:"matches_found_on_first_page,omitempty"`
	NumberOfPagesOfResults                        uint32                                `protobuf:"varint,6,opt,name=number_of_pages_of_results,json=numberOfPagesOfResults,proto3" json:"number_of_pages_of_results,omitempty"`
	UrlOfFirstMatchInPage                         string                                `protobuf:"bytes,7,opt,name=url_of_first_match_in_page,json=urlOfFirstMatchInPage,proto3" json:"url_of_first_match_in_page,omitempty"`
	OpenNsfwScore                                 float32                               `protobuf:"fixed32,8,opt,name=open_nsfw_score,json=openNsfwScore,proto3" json:"open_nsfw_score,omitempty"`
	ZstdCompressedFingerprint                     []byte                                `protobuf:"bytes,9,opt,name=zstd_compressed_fingerprint,json=zstdCompressedFingerprint,proto3" json:"zstd_compressed_fingerprint,omitempty"`
	AlternativeNsfwScore                          *ProbeImageReply_AlternativeNSFWScore `protobuf:"bytes,10,opt,name=alternative_nsfw_score,json=alternativeNsfwScore,proto3" json:"alternative_nsfw_score,omitempty"`
	ImageHashes                                   *ProbeImageReply_ImageHashes          `protobuf:"bytes,11,opt,name=image_hashes,json=imageHashes,proto3" json:"image_hashes,omitempty"`
	PerceptualHashOverlapCount                    uint32                                `protobuf:"varint,12,opt,name=perceptual_hash_overlap_count,json=perceptualHashOverlapCount,proto3" json:"perceptual_hash_overlap_count,omitempty"`
	NumberOfFingerprintsRequiringFurtherTesting_1 uint32                                `protobuf:"varint,13,opt,name=number_of_fingerprints_requiring_further_testing_1,json=numberOfFingerprintsRequiringFurtherTesting1,proto3" json:"number_of_fingerprints_requiring_further_testing_1,omitempty"`
	NumberOfFingerprintsRequiringFurtherTesting_2 uint32                                `protobuf:"varint,14,opt,name=number_of_fingerprints_requiring_further_testing_2,json=numberOfFingerprintsRequiringFurtherTesting2,proto3" json:"number_of_fingerprints_requiring_further_testing_2,omitempty"`
	NumberOfFingerprintsRequiringFurtherTesting_3 uint32                                `protobuf:"varint,15,opt,name=number_of_fingerprints_requiring_further_testing_3,json=numberOfFingerprintsRequiringFurtherTesting3,proto3" json:"number_of_fingerprints_requiring_further_testing_3,omitempty"`
	NumberOfFingerprintsRequiringFurtherTesting_4 uint32                                `protobuf:"varint,16,opt,name=number_of_fingerprints_requiring_further_testing_4,json=numberOfFingerprintsRequiringFurtherTesting4,proto3" json:"number_of_fingerprints_requiring_further_testing_4,omitempty"`
	NumberOfFingerprintsRequiringFurtherTesting_5 uint32                                `protobuf:"varint,17,opt,name=number_of_fingerprints_requiring_further_testing_5,json=numberOfFingerprintsRequiringFurtherTesting5,proto3" json:"number_of_fingerprints_requiring_further_testing_5,omitempty"`
	NumberOfFingerprintsRequiringFurtherTesting_6 uint32                                `protobuf:"varint,18,opt,name=number_of_fingerprints_requiring_further_testing_6,json=numberOfFingerprintsRequiringFurtherTesting6,proto3" json:"number_of_fingerprints_requiring_further_testing_6,omitempty"`
	NumberOfFingerprintsOfSuspectedDupes          uint32                                `protobuf:"varint,19,opt,name=number_of_fingerprints_of_suspected_dupes,json=numberOfFingerprintsOfSuspectedDupes,proto3" json:"number_of_fingerprints_of_suspected_dupes,omitempty"`
	PearsonMax                                    float32                               `protobuf:"fixed32,20,opt,name=pearson_max,json=pearsonMax,proto3" json:"pearson_max,omitempty"`
	SpearmanMax                                   float32                               `protobuf:"fixed32,21,opt,name=spearman_max,json=spearmanMax,proto3" json:"spearman_max,omitempty"`
	KendallMax                                    float32                               `protobuf:"fixed32,22,opt,name=kendall_max,json=kendallMax,proto3" json:"kendall_max,omitempty"`
	HoeffdingMax                                  float32                               `protobuf:"fixed32,23,opt,name=hoeffding_max,json=hoeffdingMax,proto3" json:"hoeffding_max,omitempty"`
	MutualInformationMax                          float32                               `protobuf:"fixed32,24,opt,name=mutual_information_max,json=mutualInformationMax,proto3" json:"mutual_information_max,omitempty"`
	HsicMax                                       float32                               `protobuf:"fixed32,25,opt,name=hsic_max,json=hsicMax,proto3" json:"hsic_max,omitempty"`
	XgbimportanceMax                              float32                               `protobuf:"fixed32,26,opt,name=xgbimportance_max,json=xgbimportanceMax,proto3" json:"xgbimportance_max,omitempty"`
	PearsonTop_1BpsPercentile                     float32                               `protobuf:"fixed32,27,opt,name=pearson_top_1_bps_percentile,json=pearsonTop1BpsPercentile,proto3" json:"pearson_top_1_bps_percentile,omitempty"`
	SpearmanTop_1BpsPercentile                    float32                               `protobuf:"fixed32,28,opt,name=spearman_top_1_bps_percentile,json=spearmanTop1BpsPercentile,proto3" json:"spearman_top_1_bps_percentile,omitempty"`
	KendallTop_1BpsPercentile                     float32                               `protobuf:"fixed32,29,opt,name=kendall_top_1_bps_percentile,json=kendallTop1BpsPercentile,proto3" json:"kendall_top_1_bps_percentile,omitempty"`
	HoeffdingTop_10BpsPercentile                  float32                               `protobuf:"fixed32,30,opt,name=hoeffding_top_10_bps_percentile,json=hoeffdingTop10BpsPercentile,proto3" json:"hoeffding_top_10_bps_percentile,omitempty"`
	MutualInformationTop_100BpsPercentile         float32                               `protobuf:"fixed32,31,opt,name=mutual_information_top_100_bps_percentile,json=mutualInformationTop100BpsPercentile,proto3" json:"mutual_information_top_100_bps_percentile,omitempty"`
	HsicTop_100BpsPercentile                      float32                               `protobuf:"fixed32,32,opt,name=hsic_top_100_bps_percentile,json=hsicTop100BpsPercentile,proto3" json:"hsic_top_100_bps_percentile,omitempty"`
	XgbimportanceTop_100BpsPercentile             float32                               `protobuf:"fixed32,33,opt,name=xgbimportance_top_100_bps_percentile,json=xgbimportanceTop100BpsPercentile,proto3" json:"xgbimportance_top_100_bps_percentile,omitempty"`
	CombinedRarenessScore                         float32                               `protobuf:"fixed32,34,opt,name=combined_rareness_score,json=combinedRarenessScore,proto3" json:"combined_rareness_score,omitempty"`
	XgboostPredictedRarenessScore                 float32                               `protobuf:"fixed32,35,opt,name=xgboost_predicted_rareness_score,json=xgboostPredictedRarenessScore,proto3" json:"xgboost_predicted_rareness_score,omitempty"`
	NnPredictedRarenessScore                      float32                               `protobuf:"fixed32,36,opt,name=nn_predicted_rareness_score,json=nnPredictedRarenessScore,proto3" json:"nn_predicted_rareness_score,omitempty"`
	OverallAverageRarenessScore                   float32                               `protobuf:"fixed32,37,opt,name=overall_average_rareness_score,json=overallAverageRarenessScore,proto3" json:"overall_average_rareness_score,omitempty"`
	IsLikelyDupe                                  bool                                  `protobuf:"varint,38,opt,name=is_likely_dupe,json=isLikelyDupe,proto3" json:"is_likely_dupe,omitempty"`
}

func (m *ProbeImageReply) Reset()      { *m = ProbeImageReply{} }
func (*ProbeImageReply) ProtoMessage() {}
func (*ProbeImageReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{7}
}
func (m *ProbeImageReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProbeImageReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProbeImageReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProbeImageReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeImageReply.Merge(m, src)
}
func (m *ProbeImageReply) XXX_Size() int {
	return m.Size()
}
func (m *ProbeImageReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeImageReply.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeImageReply proto.InternalMessageInfo

func (m *ProbeImageReply) GetDupeDetectionVersion() string {
	if m != nil {
		return m.DupeDetectionVersion
	}
	return ""
}

func (m *ProbeImageReply) GetHashOfCandidateImg() string {
	if m != nil {
		return m.HashOfCandidateImg
	}
	return ""
}

func (m *ProbeImageReply) GetAverageRarenessScore() float32 {
	if m != nil {
		return m.AverageRarenessScore
	}
	return 0
}

func (m *ProbeImageReply) GetIsRareOnInternet() bool {
	if m != nil {
		return m.IsRareOnInternet
	}
	return false
}

func (m *ProbeImageReply) GetMatchesFoundOnFirstPage() uint32 {
	if m != nil {
		return m.MatchesFoundOnFirstPage
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfPagesOfResults() uint32 {
	if m != nil {
		return m.NumberOfPagesOfResults
	}
	return 0
}

func (m *ProbeImageReply) GetUrlOfFirstMatchInPage() string {
	if m != nil {
		return m.UrlOfFirstMatchInPage
	}
	return ""
}

func (m *ProbeImageReply) GetOpenNsfwScore() float32 {
	if m != nil {
		return m.OpenNsfwScore
	}
	return 0
}

func (m *ProbeImageReply) GetZstdCompressedFingerprint() []byte {
	if m != nil {
		return m.ZstdCompressedFingerprint
	}
	return nil
}

func (m *ProbeImageReply) GetAlternativeNsfwScore() *ProbeImageReply_AlternativeNSFWScore {
	if m != nil {
		return m.AlternativeNsfwScore
	}
	return nil
}

func (m *ProbeImageReply) GetImageHashes() *ProbeImageReply_ImageHashes {
	if m != nil {
		return m.ImageHashes
	}
	return nil
}

func (m *ProbeImageReply) GetPerceptualHashOverlapCount() uint32 {
	if m != nil {
		return m.PerceptualHashOverlapCount
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsRequiringFurtherTesting_1() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsRequiringFurtherTesting_1
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsRequiringFurtherTesting_2() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsRequiringFurtherTesting_2
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsRequiringFurtherTesting_3() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsRequiringFurtherTesting_3
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsRequiringFurtherTesting_4() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsRequiringFurtherTesting_4
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsRequiringFurtherTesting_5() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsRequiringFurtherTesting_5
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsRequiringFurtherTesting_6() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsRequiringFurtherTesting_6
	}
	return 0
}

func (m *ProbeImageReply) GetNumberOfFingerprintsOfSuspectedDupes() uint32 {
	if m != nil {
		return m.NumberOfFingerprintsOfSuspectedDupes
	}
	return 0
}

func (m *ProbeImageReply) GetPearsonMax() float32 {
	if m != nil {
		return m.PearsonMax
	}
	return 0
}

func (m *ProbeImageReply) GetSpearmanMax() float32 {
	if m != nil {
		return m.SpearmanMax
	}
	return 0
}

func (m *ProbeImageReply) GetKendallMax() float32 {
	if m != nil {
		return m.KendallMax
	}
	return 0
}

func (m *ProbeImageReply) GetHoeffdingMax() float32 {
	if m != nil {
		return m.HoeffdingMax
	}
	return 0
}

func (m *ProbeImageReply) GetMutualInformationMax() float32 {
	if m != nil {
		return m.MutualInformationMax
	}
	return 0
}

func (m *ProbeImageReply) GetHsicMax() float32 {
	if m != nil {
		return m.HsicMax
	}
	return 0
}

func (m *ProbeImageReply) GetXgbimportanceMax() float32 {
	if m != nil {
		return m.XgbimportanceMax
	}
	return 0
}

func (m *ProbeImageReply) GetPearsonTop_1BpsPercentile() float32 {
	if m != nil {
		return m.PearsonTop_1BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetSpearmanTop_1BpsPercentile() float32 {
	if m != nil {
		return m.SpearmanTop_1BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetKendallTop_1BpsPercentile() float32 {
	if m != nil {
		return m.KendallTop_1BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetHoeffdingTop_10BpsPercentile() float32 {
	if m != nil {
		return m.HoeffdingTop_10BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetMutualInformationTop_100BpsPercentile() float32 {
	if m != nil {
		return m.MutualInformationTop_100BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetHsicTop_100BpsPercentile() float32 {
	if m != nil {
		return m.HsicTop_100BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetXgbimportanceTop_100BpsPercentile() float32 {
	if m != nil {
		return m.XgbimportanceTop_100BpsPercentile
	}
	return 0
}

func (m *ProbeImageReply) GetCombinedRarenessScore() float32 {
	if m != nil {
		return m.CombinedRarenessScore
	}
	return 0
}

func (m *ProbeImageReply) GetXgboostPredictedRarenessScore() float32 {
	if m != nil {
		return m.XgboostPredictedRarenessScore
	}
	return 0
}

func (m *ProbeImageReply) GetNnPredictedRarenessScore() float32 {
	if m != nil {
		return m.NnPredictedRarenessScore
	}
	return 0
}

func (m *ProbeImageReply) GetOverallAverageRarenessScore() float32 {
	if m != nil {
		return m.OverallAverageRarenessScore
	}
	return 0
}

func (m *ProbeImageReply) GetIsLikelyDupe() bool {
	if m != nil {
		return m.IsLikelyDupe
	}
	return false
}

type ProbeImageReply_AlternativeNSFWScore struct {
	Drawing float32 `protobuf:"fixed32,1,opt,name=drawing,proto3" json:"drawing,omitempty"`
	Hentai  float32 `protobuf:"fixed32,2,opt,name=hentai,proto3" json:"hentai,omitempty"`
	Neutral float32 `protobuf:"fixed32,3,opt,name=neutral,proto3" json:"neutral,omitempty"`
	Porn    float32 `protobuf:"fixed32,4,opt,name=porn,proto3" json:"porn,omitempty"`
	Sexy    float32 `protobuf:"fixed32,5,opt,name=sexy,proto3" json:"sexy,omitempty"`
}

func (m *ProbeImageReply_AlternativeNSFWScore) Reset()      { *m = ProbeImageReply_AlternativeNSFWScore{} }
func (*ProbeImageReply_AlternativeNSFWScore) ProtoMessage() {}
func (*ProbeImageReply_AlternativeNSFWScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{7, 0}
}
func (m *ProbeImageReply_AlternativeNSFWScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProbeImageReply_AlternativeNSFWScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProbeImageReply_AlternativeNSFWScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProbeImageReply_AlternativeNSFWScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeImageReply_AlternativeNSFWScore.Merge(m, src)
}
func (m *ProbeImageReply_AlternativeNSFWScore) XXX_Size() int {
	return m.Size()
}
func (m *ProbeImageReply_AlternativeNSFWScore) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeImageReply_AlternativeNSFWScore.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeImageReply_AlternativeNSFWScore proto.InternalMessageInfo

func (m *ProbeImageReply_AlternativeNSFWScore) GetDrawing() float32 {
	if m != nil {
		return m.Drawing
	}
	return 0
}

func (m *ProbeImageReply_AlternativeNSFWScore) GetHentai() float32 {
	if m != nil {
		return m.Hentai
	}
	return 0
}

func (m *ProbeImageReply_AlternativeNSFWScore) GetNeutral() float32 {
	if m != nil {
		return m.Neutral
	}
	return 0
}

func (m *ProbeImageReply_AlternativeNSFWScore) GetPorn() float32 {
	if m != nil {
		return m.Porn
	}
	return 0
}

func (m *ProbeImageReply_AlternativeNSFWScore) GetSexy() float32 {
	if m != nil {
		return m.Sexy
	}
	return 0
}

type ProbeImageReply_ImageHashes struct {
	PerceptualHash string `protobuf:"bytes,1,opt,name=perceptual_hash,json=perceptualHash,proto3" json:"perceptual_hash,omitempty"`
	AverageHash    string `protobuf:"bytes,2,opt,name=average_hash,json=averageHash,proto3" json:"average_hash,omitempty"`
	DifferenceHash string `protobuf:"bytes,3,opt,name=difference_hash,json=differenceHash,proto3" json:"difference_hash,omitempty"`
	PDQHash        string `protobuf:"bytes,4,opt,name=PDQ_hash,json=PDQHash,proto3" json:"PDQ_hash,omitempty"`
	NeuralHash     string `protobuf:"bytes,5,opt,name=neural_hash,json=neuralHash,proto3" json:"neural_hash,omitempty"`
}

func (m *ProbeImageReply_ImageHashes) Reset()      { *m = ProbeImageReply_ImageHashes{} }
func (*ProbeImageReply_ImageHashes) ProtoMessage() {}
func (*ProbeImageReply_ImageHashes) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{7, 1}
}
func (m *ProbeImageReply_ImageHashes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProbeImageReply_ImageHashes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProbeImageReply_ImageHashes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProbeImageReply_ImageHashes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProbeImageReply_ImageHashes.Merge(m, src)
}
func (m *ProbeImageReply_ImageHashes) XXX_Size() int {
	return m.Size()
}
func (m *ProbeImageReply_ImageHashes) XXX_DiscardUnknown() {
	xxx_messageInfo_ProbeImageReply_ImageHashes.DiscardUnknown(m)
}

var xxx_messageInfo_ProbeImageReply_ImageHashes proto.InternalMessageInfo

func (m *ProbeImageReply_ImageHashes) GetPerceptualHash() string {
	if m != nil {
		return m.PerceptualHash
	}
	return ""
}

func (m *ProbeImageReply_ImageHashes) GetAverageHash() string {
	if m != nil {
		return m.AverageHash
	}
	return ""
}

func (m *ProbeImageReply_ImageHashes) GetDifferenceHash() string {
	if m != nil {
		return m.DifferenceHash
	}
	return ""
}

func (m *ProbeImageReply_ImageHashes) GetPDQHash() string {
	if m != nil {
		return m.PDQHash
	}
	return ""
}

func (m *ProbeImageReply_ImageHashes) GetNeuralHash() string {
	if m != nil {
		return m.NeuralHash
	}
	return ""
}

type EncoderParameters struct {
	Oti []byte `protobuf:"bytes,1,opt,name=oti,proto3" json:"oti,omitempty"`
}

func (m *EncoderParameters) Reset()      { *m = EncoderParameters{} }
func (*EncoderParameters) ProtoMessage() {}
func (*EncoderParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{8}
}
func (m *EncoderParameters) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncoderParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncoderParameters.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncoderParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncoderParameters.Merge(m, src)
}
func (m *EncoderParameters) XXX_Size() int {
	return m.Size()
}
func (m *EncoderParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_EncoderParameters.DiscardUnknown(m)
}

var xxx_messageInfo_EncoderParameters proto.InternalMessageInfo

func (m *EncoderParameters) GetOti() []byte {
	if m != nil {
		return m.Oti
	}
	return nil
}

type SendSignedNFTTicketRequest struct {
	NftTicket        []byte             `protobuf:"bytes,1,opt,name=nft_ticket,json=nftTicket,proto3" json:"nft_ticket,omitempty"`
	CreatorSignature []byte             `protobuf:"bytes,2,opt,name=creator_signature,json=creatorSignature,proto3" json:"creator_signature,omitempty"`
	Key1             string             `protobuf:"bytes,3,opt,name=key1,proto3" json:"key1,omitempty"`
	Key2             string             `protobuf:"bytes,4,opt,name=key2,proto3" json:"key2,omitempty"`
	EncodeParameters *EncoderParameters `protobuf:"bytes,5,opt,name=encode_parameters,json=encodeParameters,proto3" json:"encode_parameters,omitempty"`
	EncodeFiles      map[string][]byte  `protobuf:"bytes,6,rep,name=encode_files,json=encodeFiles,proto3" json:"encode_files,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SendSignedNFTTicketRequest) Reset()      { *m = SendSignedNFTTicketRequest{} }
func (*SendSignedNFTTicketRequest) ProtoMessage() {}
func (*SendSignedNFTTicketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{9}
}
func (m *SendSignedNFTTicketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSignedNFTTicketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSignedNFTTicketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendSignedNFTTicketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSignedNFTTicketRequest.Merge(m, src)
}
func (m *SendSignedNFTTicketRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendSignedNFTTicketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSignedNFTTicketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendSignedNFTTicketRequest proto.InternalMessageInfo

func (m *SendSignedNFTTicketRequest) GetNftTicket() []byte {
	if m != nil {
		return m.NftTicket
	}
	return nil
}

func (m *SendSignedNFTTicketRequest) GetCreatorSignature() []byte {
	if m != nil {
		return m.CreatorSignature
	}
	return nil
}

func (m *SendSignedNFTTicketRequest) GetKey1() string {
	if m != nil {
		return m.Key1
	}
	return ""
}

func (m *SendSignedNFTTicketRequest) GetKey2() string {
	if m != nil {
		return m.Key2
	}
	return ""
}

func (m *SendSignedNFTTicketRequest) GetEncodeParameters() *EncoderParameters {
	if m != nil {
		return m.EncodeParameters
	}
	return nil
}

func (m *SendSignedNFTTicketRequest) GetEncodeFiles() map[string][]byte {
	if m != nil {
		return m.EncodeFiles
	}
	return nil
}

type SendSignedNFTTicketReply struct {
	RegistrationFee int64 `protobuf:"varint,1,opt,name=registration_fee,json=registrationFee,proto3" json:"registration_fee,omitempty"`
}

func (m *SendSignedNFTTicketReply) Reset()      { *m = SendSignedNFTTicketReply{} }
func (*SendSignedNFTTicketReply) ProtoMessage() {}
func (*SendSignedNFTTicketReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{10}
}
func (m *SendSignedNFTTicketReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendSignedNFTTicketReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendSignedNFTTicketReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendSignedNFTTicketReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendSignedNFTTicketReply.Merge(m, src)
}
func (m *SendSignedNFTTicketReply) XXX_Size() int {
	return m.Size()
}
func (m *SendSignedNFTTicketReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SendSignedNFTTicketReply.DiscardUnknown(m)
}

var xxx_messageInfo_SendSignedNFTTicketReply proto.InternalMessageInfo

func (m *SendSignedNFTTicketReply) GetRegistrationFee() int64 {
	if m != nil {
		return m.RegistrationFee
	}
	return 0
}

type SendPreBurntFeeTxidRequest struct {
	Txid string `protobuf:"bytes,1,opt,name=txid,proto3" json:"txid,omitempty"`
}

func (m *SendPreBurntFeeTxidRequest) Reset()      { *m = SendPreBurntFeeTxidRequest{} }
func (*SendPreBurntFeeTxidRequest) ProtoMessage() {}
func (*SendPreBurntFeeTxidRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{11}
}
func (m *SendPreBurntFeeTxidRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPreBurntFeeTxidRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPreBurntFeeTxidRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPreBurntFeeTxidRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPreBurntFeeTxidRequest.Merge(m, src)
}
func (m *SendPreBurntFeeTxidRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendPreBurntFeeTxidRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPreBurntFeeTxidRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendPreBurntFeeTxidRequest proto.InternalMessageInfo

func (m *SendPreBurntFeeTxidRequest) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

type SendPreBurntFeeTxidReply struct {
	NFTRegTxid string `protobuf:"bytes,1,opt,name=NFT_reg_txid,json=NFTRegTxid,proto3" json:"NFT_reg_txid,omitempty"`
}

func (m *SendPreBurntFeeTxidReply) Reset()      { *m = SendPreBurntFeeTxidReply{} }
func (*SendPreBurntFeeTxidReply) ProtoMessage() {}
func (*SendPreBurntFeeTxidReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{12}
}
func (m *SendPreBurntFeeTxidReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendPreBurntFeeTxidReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendPreBurntFeeTxidReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendPreBurntFeeTxidReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendPreBurntFeeTxidReply.Merge(m, src)
}
func (m *SendPreBurntFeeTxidReply) XXX_Size() int {
	return m.Size()
}
func (m *SendPreBurntFeeTxidReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SendPreBurntFeeTxidReply.DiscardUnknown(m)
}

var xxx_messageInfo_SendPreBurntFeeTxidReply proto.InternalMessageInfo

func (m *SendPreBurntFeeTxidReply) GetNFTRegTxid() string {
	if m != nil {
		return m.NFTRegTxid
	}
	return ""
}

type SendTicketRequest struct {
	Ticket          []byte `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	TicketSignature string `protobuf:"bytes,2,opt,name=ticket_signature,json=ticketSignature,proto3" json:"ticket_signature,omitempty"`
	Fgpt            string `protobuf:"bytes,3,opt,name=fgpt,proto3" json:"fgpt,omitempty"`
	FgptSignature   string `protobuf:"bytes,4,opt,name=fgpt_signature,json=fgptSignature,proto3" json:"fgpt_signature,omitempty"`
	FeeTxid         string `protobuf:"bytes,5,opt,name=fee_txid,json=feeTxid,proto3" json:"fee_txid,omitempty"`
	Thumbnail       []byte `protobuf:"bytes,6,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *SendTicketRequest) Reset()      { *m = SendTicketRequest{} }
func (*SendTicketRequest) ProtoMessage() {}
func (*SendTicketRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{13}
}
func (m *SendTicketRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTicketRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTicketRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendTicketRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTicketRequest.Merge(m, src)
}
func (m *SendTicketRequest) XXX_Size() int {
	return m.Size()
}
func (m *SendTicketRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTicketRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SendTicketRequest proto.InternalMessageInfo

func (m *SendTicketRequest) GetTicket() []byte {
	if m != nil {
		return m.Ticket
	}
	return nil
}

func (m *SendTicketRequest) GetTicketSignature() string {
	if m != nil {
		return m.TicketSignature
	}
	return ""
}

func (m *SendTicketRequest) GetFgpt() string {
	if m != nil {
		return m.Fgpt
	}
	return ""
}

func (m *SendTicketRequest) GetFgptSignature() string {
	if m != nil {
		return m.FgptSignature
	}
	return ""
}

func (m *SendTicketRequest) GetFeeTxid() string {
	if m != nil {
		return m.FeeTxid
	}
	return ""
}

func (m *SendTicketRequest) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

type SendTicketReply struct {
	TicketTxid string `protobuf:"bytes,1,opt,name=ticket_txid,json=ticketTxid,proto3" json:"ticket_txid,omitempty"`
}

func (m *SendTicketReply) Reset()      { *m = SendTicketReply{} }
func (*SendTicketReply) ProtoMessage() {}
func (*SendTicketReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{14}
}
func (m *SendTicketReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SendTicketReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SendTicketReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SendTicketReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SendTicketReply.Merge(m, src)
}
func (m *SendTicketReply) XXX_Size() int {
	return m.Size()
}
func (m *SendTicketReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SendTicketReply.DiscardUnknown(m)
}

var xxx_messageInfo_SendTicketReply proto.InternalMessageInfo

func (m *SendTicketReply) GetTicketTxid() string {
	if m != nil {
		return m.TicketTxid
	}
	return ""
}

type UploadImageRequest struct {
	// Types that are valid to be assigned to Payload:
	//	*UploadImageRequest_ImagePiece
	//	*UploadImageRequest_MetaData_
	Payload isUploadImageRequest_Payload `protobuf_oneof:"payload"`
}

func (m *UploadImageRequest) Reset()      { *m = UploadImageRequest{} }
func (*UploadImageRequest) ProtoMessage() {}
func (*UploadImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{15}
}
func (m *UploadImageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadImageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadImageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadImageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadImageRequest.Merge(m, src)
}
func (m *UploadImageRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadImageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadImageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadImageRequest proto.InternalMessageInfo

type isUploadImageRequest_Payload interface {
	isUploadImageRequest_Payload()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type UploadImageRequest_ImagePiece struct {
	ImagePiece []byte `protobuf:"bytes,1,opt,name=image_piece,json=imagePiece,proto3,oneof" json:"image_piece,omitempty"`
}
type UploadImageRequest_MetaData_ struct {
	MetaData *UploadImageRequest_MetaData `protobuf:"bytes,2,opt,name=meta_data,json=metaData,proto3,oneof" json:"meta_data,omitempty"`
}

func (*UploadImageRequest_ImagePiece) isUploadImageRequest_Payload() {}
func (*UploadImageRequest_MetaData_) isUploadImageRequest_Payload()  {}

func (m *UploadImageRequest) GetPayload() isUploadImageRequest_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *UploadImageRequest) GetImagePiece() []byte {
	if x, ok := m.GetPayload().(*UploadImageRequest_ImagePiece); ok {
		return x.ImagePiece
	}
	return nil
}

func (m *UploadImageRequest) GetMetaData() *UploadImageRequest_MetaData {
	if x, ok := m.GetPayload().(*UploadImageRequest_MetaData_); ok {
		return x.MetaData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadImageRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadImageRequest_ImagePiece)(nil),
		(*UploadImageRequest_MetaData_)(nil),
	}
}

type UploadImageRequest_Coordinate struct {
	TopLeftX     int64 `protobuf:"varint,1,opt,name=top_left_x,json=topLeftX,proto3" json:"top_left_x,omitempty"`
	TopLeftY     int64 `protobuf:"varint,2,opt,name=top_left_y,json=topLeftY,proto3" json:"top_left_y,omitempty"`
	BottomRightX int64 `protobuf:"varint,3,opt,name=bottom_right_x,json=bottomRightX,proto3" json:"bottom_right_x,omitempty"`
	BottomRightY int64 `protobuf:"varint,4,opt,name=bottom_right_y,json=bottomRightY,proto3" json:"bottom_right_y,omitempty"`
}

func (m *UploadImageRequest_Coordinate) Reset()      { *m = UploadImageRequest_Coordinate{} }
func (*UploadImageRequest_Coordinate) ProtoMessage() {}
func (*UploadImageRequest_Coordinate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{15, 0}
}
func (m *UploadImageRequest_Coordinate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadImageRequest_Coordinate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadImageRequest_Coordinate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadImageRequest_Coordinate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadImageRequest_Coordinate.Merge(m, src)
}
func (m *UploadImageRequest_Coordinate) XXX_Size() int {
	return m.Size()
}
func (m *UploadImageRequest_Coordinate) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadImageRequest_Coordinate.DiscardUnknown(m)
}

var xxx_messageInfo_UploadImageRequest_Coordinate proto.InternalMessageInfo

func (m *UploadImageRequest_Coordinate) GetTopLeftX() int64 {
	if m != nil {
		return m.TopLeftX
	}
	return 0
}

func (m *UploadImageRequest_Coordinate) GetTopLeftY() int64 {
	if m != nil {
		return m.TopLeftY
	}
	return 0
}

func (m *UploadImageRequest_Coordinate) GetBottomRightX() int64 {
	if m != nil {
		return m.BottomRightX
	}
	return 0
}

func (m *UploadImageRequest_Coordinate) GetBottomRightY() int64 {
	if m != nil {
		return m.BottomRightY
	}
	return 0
}

type UploadImageRequest_MetaData struct {
	// size of the image
	Size_ int64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// valid image format such as jpeg, png ...
	Format string `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	// sha3-256 hash of the image
	Hash []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
	// thumbnail of the image
	Thumbnail *UploadImageRequest_Coordinate `protobuf:"bytes,4,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *UploadImageRequest_MetaData) Reset()      { *m = UploadImageRequest_MetaData{} }
func (*UploadImageRequest_MetaData) ProtoMessage() {}
func (*UploadImageRequest_MetaData) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{15, 1}
}
func (m *UploadImageRequest_MetaData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadImageRequest_MetaData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadImageRequest_MetaData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadImageRequest_MetaData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadImageRequest_MetaData.Merge(m, src)
}
func (m *UploadImageRequest_MetaData) XXX_Size() int {
	return m.Size()
}
func (m *UploadImageRequest_MetaData) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadImageRequest_MetaData.DiscardUnknown(m)
}

var xxx_messageInfo_UploadImageRequest_MetaData proto.InternalMessageInfo

func (m *UploadImageRequest_MetaData) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *UploadImageRequest_MetaData) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *UploadImageRequest_MetaData) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *UploadImageRequest_MetaData) GetThumbnail() *UploadImageRequest_Coordinate {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

type UploadImageReply struct {
	PreviewThumbnailHash []byte `protobuf:"bytes,1,opt,name=preview_thumbnail_hash,json=previewThumbnailHash,proto3" json:"preview_thumbnail_hash,omitempty"`
	MediumThumbnailHash  []byte `protobuf:"bytes,2,opt,name=medium_thumbnail_hash,json=mediumThumbnailHash,proto3" json:"medium_thumbnail_hash,omitempty"`
	SmallThumbnailHash   []byte `protobuf:"bytes,3,opt,name=small_thumbnail_hash,json=smallThumbnailHash,proto3" json:"small_thumbnail_hash,omitempty"`
}

func (m *UploadImageReply) Reset()      { *m = UploadImageReply{} }
func (*UploadImageReply) ProtoMessage() {}
func (*UploadImageReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6f255918905bb010, []int{16}
}
func (m *UploadImageReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadImageReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadImageReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadImageReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadImageReply.Merge(m, src)
}
func (m *UploadImageReply) XXX_Size() int {
	return m.Size()
}
func (m *UploadImageReply) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadImageReply.DiscardUnknown(m)
}

var xxx_messageInfo_UploadImageReply proto.InternalMessageInfo

func (m *UploadImageReply) GetPreviewThumbnailHash() []byte {
	if m != nil {
		return m.PreviewThumbnailHash
	}
	return nil
}

func (m *UploadImageReply) GetMediumThumbnailHash() []byte {
	if m != nil {
		return m.MediumThumbnailHash
	}
	return nil
}

func (m *UploadImageReply) GetSmallThumbnailHash() []byte {
	if m != nil {
		return m.SmallThumbnailHash
	}
	return nil
}

func init() {
	proto.RegisterType((*SessionRequest)(nil), "walletnode.SessionRequest")
	proto.RegisterType((*SessionReply)(nil), "walletnode.SessionReply")
	proto.RegisterType((*AcceptedNodesRequest)(nil), "walletnode.AcceptedNodesRequest")
	proto.RegisterType((*AcceptedNodesReply)(nil), "walletnode.AcceptedNodesReply")
	proto.RegisterType((*AcceptedNodesReply_Peer)(nil), "walletnode.AcceptedNodesReply.Peer")
	proto.RegisterType((*ConnectToRequest)(nil), "walletnode.ConnectToRequest")
	proto.RegisterType((*ConnectToReply)(nil), "walletnode.ConnectToReply")
	proto.RegisterType((*ProbeImageRequest)(nil), "walletnode.ProbeImageRequest")
	proto.RegisterType((*ProbeImageReply)(nil), "walletnode.ProbeImageReply")
	proto.RegisterType((*ProbeImageReply_AlternativeNSFWScore)(nil), "walletnode.ProbeImageReply.AlternativeNSFWScore")
	proto.RegisterType((*ProbeImageReply_ImageHashes)(nil), "walletnode.ProbeImageReply.ImageHashes")
	proto.RegisterType((*EncoderParameters)(nil), "walletnode.EncoderParameters")
	proto.RegisterType((*SendSignedNFTTicketRequest)(nil), "walletnode.SendSignedNFTTicketRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "walletnode.SendSignedNFTTicketRequest.EncodeFilesEntry")
	proto.RegisterType((*SendSignedNFTTicketReply)(nil), "walletnode.SendSignedNFTTicketReply")
	proto.RegisterType((*SendPreBurntFeeTxidRequest)(nil), "walletnode.SendPreBurntFeeTxidRequest")
	proto.RegisterType((*SendPreBurntFeeTxidReply)(nil), "walletnode.SendPreBurntFeeTxidReply")
	proto.RegisterType((*SendTicketRequest)(nil), "walletnode.SendTicketRequest")
	proto.RegisterType((*SendTicketReply)(nil), "walletnode.SendTicketReply")
	proto.RegisterType((*UploadImageRequest)(nil), "walletnode.UploadImageRequest")
	proto.RegisterType((*UploadImageRequest_Coordinate)(nil), "walletnode.UploadImageRequest.Coordinate")
	proto.RegisterType((*UploadImageRequest_MetaData)(nil), "walletnode.UploadImageRequest.MetaData")
	proto.RegisterType((*UploadImageReply)(nil), "walletnode.UploadImageReply")
}

func init() { proto.RegisterFile("walletnode/register_artwork.proto", fileDescriptor_6f255918905bb010) }

var fileDescriptor_6f255918905bb010 = []byte{
	// 2133 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x3d, 0x54, 0x1c, 0xc9,
	0x11, 0x66, 0x00, 0x09, 0xa8, 0x5d, 0xfe, 0x46, 0x08, 0x0d, 0x0b, 0x2c, 0x68, 0x0f, 0x49, 0xe8,
	0xd9, 0x87, 0x00, 0xe9, 0x64, 0xdf, 0x3d, 0x59, 0xcf, 0x12, 0x68, 0x4f, 0xe8, 0x9d, 0x00, 0x0d,
	0xd8, 0xba, 0xbb, 0x64, 0xde, 0xb0, 0x53, 0xb3, 0xdb, 0x8f, 0x99, 0x9e, 0xb9, 0xee, 0x5e, 0x60,
	0x2f, 0x72, 0xec, 0xc8, 0xef, 0xd9, 0xb9, 0x53, 0x47, 0x4e, 0xed, 0xc8, 0xb1, 0x9f, 0x23, 0x85,
	0x17, 0x5a, 0x28, 0x71, 0x78, 0xa1, 0x43, 0xbf, 0xee, 0x9e, 0xd9, 0x9d, 0xd9, 0x1f, 0x9d, 0xa5,
	0x68, 0xbb, 0xab, 0xbe, 0xfa, 0xaa, 0xbb, 0xba, 0xb6, 0xa6, 0xba, 0xe1, 0xe6, 0xb9, 0x1b, 0x04,
	0x28, 0x68, 0xe4, 0xe1, 0x3d, 0x86, 0x75, 0xc2, 0x05, 0x32, 0xc7, 0x65, 0xe2, 0x3c, 0x62, 0xa7,
	0x1b, 0x31, 0x8b, 0x44, 0x64, 0x42, 0x07, 0x52, 0xb9, 0x07, 0x53, 0x47, 0xc8, 0x39, 0x89, 0xa8,
	0x8d, 0xdf, 0x35, 0x91, 0x0b, 0x73, 0x19, 0x80, 0x70, 0x27, 0x66, 0x24, 0x74, 0x59, 0xcb, 0x32,
	0x56, 0x8d, 0xf5, 0x71, 0x7b, 0x82, 0xf0, 0x43, 0x2d, 0xa8, 0xdc, 0x86, 0x62, 0xdb, 0x20, 0x0e,
	0x5a, 0xe6, 0x3c, 0x5c, 0xe5, 0xc8, 0xf9, 0xde, 0xae, 0x82, 0x4e, 0xd8, 0xc9, 0xac, 0x32, 0x0f,
	0x73, 0x4f, 0x6a, 0x35, 0x8c, 0x05, 0x7a, 0xfb, 0x91, 0x87, 0x3c, 0xa1, 0xaf, 0x44, 0x60, 0x76,
	0xc9, 0x25, 0xcb, 0xe7, 0x70, 0x25, 0x46, 0x64, 0xdc, 0x32, 0x56, 0x47, 0xd6, 0x0b, 0xdb, 0x9f,
	0x6c, 0x74, 0x96, 0xb8, 0xd1, 0x0b, 0xdf, 0x38, 0x44, 0x64, 0xb6, 0xb6, 0x28, 0x95, 0x61, 0x54,
	0x4e, 0xe5, 0x42, 0x24, 0xbc, 0xb3, 0x10, 0x3d, 0xab, 0x3c, 0x85, 0x99, 0x9d, 0x88, 0x52, 0xac,
	0x89, 0xe3, 0x28, 0xdd, 0xe3, 0x80, 0x45, 0x67, 0x38, 0x86, 0x73, 0x1c, 0x33, 0x30, 0x95, 0xe1,
	0x88, 0x83, 0x56, 0xe5, 0x53, 0x98, 0x3d, 0x64, 0xd1, 0x09, 0xee, 0x85, 0x6e, 0x1d, 0x53, 0x5a,
	0x0b, 0xc6, 0x62, 0xb7, 0x15, 0x44, 0xae, 0xa7, 0x78, 0x8b, 0x76, 0x3a, 0xad, 0xfc, 0x7d, 0x1e,
	0xa6, 0xb3, 0x78, 0xb9, 0xe7, 0x07, 0x30, 0xef, 0x35, 0x63, 0x74, 0x3c, 0x14, 0x58, 0x13, 0x24,
	0xa2, 0xce, 0x19, 0x32, 0x19, 0xd8, 0x64, 0x51, 0x73, 0x52, 0xbb, 0x9b, 0x2a, 0x7f, 0xab, 0x75,
	0xe6, 0x16, 0x5c, 0x6f, 0xb8, 0xbc, 0xe1, 0x44, 0xbe, 0x53, 0x73, 0xa9, 0x47, 0x3c, 0x57, 0xa0,
	0x43, 0xc2, 0x7a, 0xb2, 0x62, 0x53, 0x2a, 0x0f, 0xfc, 0x9d, 0x54, 0xb5, 0x17, 0xd6, 0xa5, 0x23,
	0xf7, 0x0c, 0x99, 0x5b, 0x47, 0x87, 0xb9, 0x0c, 0x29, 0x72, 0xee, 0xf0, 0x5a, 0xc4, 0xd0, 0x1a,
	0x59, 0x35, 0xd6, 0x87, 0xed, 0xb9, 0x44, 0x6b, 0x27, 0xca, 0x23, 0xa9, 0x33, 0x3f, 0x85, 0x6b,
	0x84, 0x2b, 0x03, 0x27, 0xa2, 0x0e, 0xa1, 0x02, 0x19, 0x45, 0x61, 0x8d, 0xaa, 0x84, 0x98, 0x21,
	0x5c, 0xa2, 0x0f, 0xe8, 0x5e, 0x22, 0x37, 0x1f, 0xc1, 0x62, 0xe8, 0x8a, 0x5a, 0x03, 0xb9, 0xe3,
	0x47, 0x4d, 0xea, 0x49, 0x23, 0x9f, 0x30, 0x2e, 0x9c, 0xd8, 0xad, 0xa3, 0x75, 0x65, 0xd5, 0x58,
	0x9f, 0xb4, 0x6f, 0x24, 0x90, 0xaa, 0x44, 0x1c, 0xd0, 0xaa, 0xd4, 0x1f, 0xba, 0x75, 0x34, 0xbf,
	0x80, 0x12, 0x6d, 0x86, 0x27, 0xc8, 0xe4, 0xbe, 0xa4, 0x01, 0x97, 0x03, 0x86, 0xbc, 0x19, 0x08,
	0x6e, 0x5d, 0x55, 0xc6, 0xf3, 0x1a, 0x71, 0xe0, 0x4b, 0x0b, 0x7e, 0xe0, 0xdb, 0x5a, 0x6b, 0x7e,
	0x0e, 0xa5, 0x26, 0x0b, 0x24, 0x5e, 0xfb, 0x53, 0x3e, 0x1c, 0x42, 0xb5, 0xe3, 0x31, 0x15, 0x96,
	0xeb, 0x4d, 0x16, 0x1c, 0xf8, 0xca, 0xdf, 0x4b, 0xa9, 0xde, 0xa3, 0xca, 0xed, 0x6d, 0x98, 0x8e,
	0x62, 0xa4, 0x0e, 0xe5, 0xfe, 0x79, 0x12, 0x92, 0x71, 0x15, 0x92, 0x49, 0x29, 0xde, 0xe7, 0xfe,
	0xb9, 0x8e, 0xc5, 0x63, 0x58, 0xfc, 0x9e, 0x0b, 0xcf, 0xa9, 0x45, 0x61, 0xcc, 0x90, 0x73, 0xf4,
	0x1c, 0x9f, 0xd0, 0x3a, 0xb2, 0x98, 0x11, 0x2a, 0xac, 0x09, 0x75, 0xd8, 0x0b, 0x12, 0xb2, 0xd3,
	0x46, 0x54, 0x3b, 0x00, 0xd3, 0x87, 0x79, 0x37, 0x90, 0x81, 0x72, 0x05, 0x39, 0xc3, 0xac, 0x3b,
	0x58, 0x35, 0xd6, 0x0b, 0xdb, 0x9b, 0xd9, 0x7c, 0xef, 0xca, 0x93, 0x8d, 0x27, 0x1d, 0xcb, 0xfd,
	0xa3, 0xea, 0x6b, 0xb5, 0x22, 0x7b, 0x2e, 0xc3, 0xd7, 0x59, 0xe7, 0x0b, 0x28, 0x12, 0x69, 0xe8,
	0xc8, 0x2c, 0x40, 0x6e, 0x15, 0x14, 0xfb, 0x9d, 0xf7, 0xb1, 0xab, 0xe1, 0x73, 0x05, 0xb7, 0x0b,
	0xa4, 0x33, 0x31, 0x9f, 0xc0, 0x72, 0x8c, 0x4c, 0xfe, 0xf5, 0x9a, 0x6e, 0xe0, 0xe8, 0x9c, 0x3b,
	0x43, 0x16, 0xb8, 0xb1, 0x53, 0x8b, 0x9a, 0x54, 0x58, 0x45, 0x75, 0x2a, 0xa5, 0x0e, 0x48, 0x1a,
	0x1e, 0x68, 0xc8, 0x8e, 0x44, 0x98, 0x0d, 0xd8, 0xee, 0x9c, 0x6a, 0x26, 0x60, 0xdc, 0x61, 0xf8,
	0x5d, 0x93, 0x30, 0x42, 0xeb, 0x8e, 0xdf, 0x64, 0xa2, 0x81, 0xcc, 0x11, 0xc8, 0x85, 0x9c, 0x6f,
	0x59, 0x93, 0x8a, 0xf7, 0xe7, 0xe9, 0x69, 0x67, 0xe2, 0xa8, 0x8a, 0x88, 0x32, 0xab, 0x6a, 0xab,
	0x63, 0x6d, 0xb4, 0xf5, 0x51, 0x9e, 0xb6, 0xad, 0xa9, 0x0f, 0xf6, 0xb4, 0xfd, 0x51, 0x9e, 0xee,
	0x5b, 0xd3, 0x1f, 0xec, 0xe9, 0xfe, 0x47, 0x79, 0x7a, 0x60, 0xcd, 0x7c, 0xb0, 0xa7, 0x07, 0x1f,
	0xe5, 0xe9, 0x33, 0x6b, 0xf6, 0x83, 0x3d, 0x7d, 0xf6, 0x51, 0x9e, 0x1e, 0x5a, 0xe6, 0x07, 0x7b,
	0x7a, 0x68, 0xbe, 0x86, 0xbb, 0x03, 0x3c, 0x45, 0xbe, 0xc3, 0x9b, 0x3c, 0xc6, 0x9a, 0x40, 0xcf,
	0x91, 0x35, 0x96, 0x5b, 0xd7, 0x94, 0x83, 0xb5, 0x7e, 0x0e, 0x0e, 0xfc, 0xa3, 0x14, 0xbc, 0x2b,
	0xb1, 0xe6, 0x0a, 0x14, 0x62, 0x74, 0x19, 0x8f, 0xa8, 0x13, 0xba, 0x17, 0xd6, 0x9c, 0xaa, 0x17,
	0x90, 0x88, 0x5e, 0xba, 0x17, 0xe6, 0x4d, 0x28, 0x72, 0x39, 0x0d, 0x5d, 0x8d, 0xb8, 0xae, 0x10,
	0x85, 0x54, 0x26, 0x21, 0x2b, 0x50, 0x38, 0x45, 0xea, 0xb9, 0x41, 0xa0, 0x10, 0xf3, 0x9a, 0x23,
	0x11, 0x49, 0xc0, 0x27, 0x30, 0xd9, 0x88, 0xd0, 0xf7, 0x3d, 0x19, 0x00, 0x09, 0xb9, 0xa1, 0x20,
	0xc5, 0xb6, 0x50, 0x82, 0x1e, 0xc0, 0x7c, 0xd8, 0x54, 0xff, 0x4e, 0x42, 0xfd, 0x88, 0x85, 0xae,
	0xfa, 0x88, 0x48, 0xb4, 0xa5, 0xeb, 0xba, 0xd6, 0xee, 0x75, 0x94, 0xd2, 0x6a, 0x01, 0xc6, 0x1b,
	0x9c, 0xd4, 0x14, 0x6e, 0x41, 0xe1, 0xc6, 0xe4, 0x5c, 0xaa, 0x7e, 0x06, 0xb3, 0x17, 0xf5, 0x13,
	0x12, 0xc6, 0x11, 0x13, 0x2e, 0xad, 0xa1, 0xc2, 0x94, 0x14, 0x66, 0x26, 0xa7, 0x90, 0xe0, 0xc7,
	0xb0, 0x94, 0xc6, 0x41, 0x44, 0xb1, 0xb3, 0xe5, 0x9c, 0xc4, 0xdc, 0x51, 0xc5, 0x80, 0x0a, 0x12,
	0xa0, 0xb5, 0xa8, 0xec, 0xac, 0x04, 0x73, 0x1c, 0xc5, 0x5b, 0x4f, 0x63, 0x7e, 0xd8, 0xd6, 0x9b,
	0xbf, 0x86, 0xe5, 0x76, 0x98, 0xfa, 0x12, 0x2c, 0x29, 0x82, 0x85, 0x14, 0xd4, 0xcb, 0xf0, 0x18,
	0x96, 0xd2, 0x28, 0xf6, 0x25, 0x58, 0xd6, 0x2b, 0x48, 0x30, 0xbd, 0xf6, 0xbb, 0xb0, 0xd2, 0x09,
	0xb2, 0x62, 0xd8, 0xec, 0xa6, 0x28, 0x2b, 0x8a, 0xc5, 0x36, 0x4c, 0x92, 0x6c, 0xe6, 0x59, 0x5e,
	0xc3, 0xdd, 0x3e, 0xa7, 0xa0, 0xe9, 0x7a, 0xf8, 0x56, 0x14, 0xdf, 0x5a, 0xcf, 0xc1, 0x28, 0xde,
	0x2e, 0xe2, 0x47, 0xb0, 0xa8, 0x0e, 0x6a, 0x00, 0xd5, 0xaa, 0xa2, 0xba, 0x21, 0x21, 0xfd, 0xac,
	0xf7, 0x61, 0x2d, 0x7f, 0x96, 0x03, 0x68, 0x6e, 0x2a, 0x9a, 0xd5, 0x1c, 0xb6, 0x1f, 0xdf, 0x43,
	0xb8, 0x51, 0x8b, 0xc2, 0x13, 0x42, 0xd1, 0xeb, 0xee, 0x22, 0x2a, 0x8a, 0xe2, 0x7a, 0xaa, 0xce,
	0xb7, 0x11, 0x5f, 0x82, 0xe4, 0x8e, 0x22, 0xd9, 0x08, 0x30, 0xf4, 0x88, 0xfa, 0xd7, 0x75, 0x11,
	0x7c, 0xa2, 0x08, 0x96, 0x13, 0xdc, 0x61, 0x0a, 0xcb, 0x13, 0xfd, 0x0a, 0x16, 0x29, 0x1d, 0xcc,
	0xb1, 0xa6, 0x0f, 0x9b, 0xd2, 0x01, 0xe6, 0x3b, 0x50, 0x96, 0x9f, 0x2f, 0x99, 0x2c, 0x03, 0x9a,
	0xa1, 0x5b, 0xfa, 0xac, 0x13, 0xd4, 0x93, 0x7e, 0x3d, 0xd1, 0x1a, 0x4c, 0x11, 0xee, 0x04, 0xe4,
	0x14, 0x83, 0x96, 0x2a, 0x1d, 0xd6, 0x6d, 0xd5, 0x0e, 0x15, 0x09, 0xff, 0x4a, 0x09, 0x65, 0x89,
	0x28, 0xfd, 0xde, 0x80, 0xb9, 0x7e, 0x1f, 0x6d, 0xd9, 0x1f, 0x7a, 0xcc, 0x3d, 0x27, 0xb4, 0xae,
	0x5a, 0xbc, 0x61, 0x3b, 0x9d, 0xca, 0xc6, 0xb3, 0x81, 0x54, 0xb8, 0x44, 0xb5, 0x71, 0xc3, 0x76,
	0x32, 0x93, 0x16, 0x14, 0x9b, 0x82, 0xb9, 0x41, 0xd2, 0xab, 0xa5, 0x53, 0xd3, 0x84, 0xd1, 0x38,
	0x62, 0x54, 0xf5, 0x63, 0xc3, 0xb6, 0x1a, 0x4b, 0x19, 0xc7, 0x8b, 0x96, 0x6a, 0xb6, 0x86, 0x6d,
	0x35, 0x2e, 0xfd, 0xc3, 0x80, 0x42, 0xe6, 0x1b, 0x6f, 0xde, 0x81, 0xe9, 0xae, 0xcf, 0x7a, 0xd2,
	0x6e, 0x4e, 0xe5, 0x3f, 0xe4, 0xb2, 0x8c, 0xa5, 0x81, 0x52, 0x28, 0xdd, 0x5f, 0x16, 0x12, 0x99,
	0x82, 0xdc, 0x81, 0x69, 0x8f, 0xf8, 0x3e, 0x32, 0x94, 0x09, 0xa6, 0x50, 0x23, 0x9a, 0xab, 0x23,
	0x56, 0xc0, 0x05, 0x18, 0x3f, 0xdc, 0x7d, 0xa5, 0x11, 0xa3, 0x0a, 0x31, 0x76, 0xb8, 0xfb, 0x4a,
	0xa9, 0x56, 0xa0, 0x40, 0xb1, 0xc9, 0xd2, 0xb5, 0x5c, 0x51, 0x5a, 0xd0, 0x22, 0x09, 0xa8, 0xdc,
	0x82, 0xd9, 0x67, 0xb4, 0x16, 0x79, 0xc8, 0x0e, 0x5d, 0xe6, 0x86, 0x28, 0x90, 0x71, 0x73, 0x06,
	0x46, 0x22, 0x41, 0x92, 0x2e, 0x5b, 0x0e, 0x2b, 0xff, 0x1d, 0x86, 0xd2, 0x11, 0x52, 0xef, 0x88,
	0xd4, 0x29, 0x7a, 0xfb, 0xd5, 0xe3, 0x63, 0x52, 0x3b, 0x45, 0x91, 0xb9, 0xd5, 0x50, 0x5f, 0x38,
	0x42, 0x09, 0x13, 0xbb, 0x09, 0xea, 0x0b, 0x8d, 0x92, 0x95, 0xaf, 0xc6, 0xd0, 0x15, 0x11, 0x73,
	0x38, 0xa9, 0x53, 0x57, 0x34, 0x19, 0xaa, 0x1d, 0x17, 0xed, 0x99, 0x44, 0x71, 0x94, 0xca, 0x65,
	0x98, 0x4f, 0xb1, 0xb5, 0x95, 0xec, 0x55, 0x8d, 0x13, 0xd9, 0x76, 0xb2, 0x3b, 0x35, 0x36, 0x5f,
	0xc0, 0x2c, 0xaa, 0x95, 0x3b, 0x71, 0x7b, 0xe5, 0x6a, 0x83, 0x85, 0xed, 0xe5, 0x6c, 0x4b, 0xd6,
	0xb3, 0x3d, 0x7b, 0x46, 0xdb, 0x65, 0x36, 0xfc, 0x2d, 0x14, 0x13, 0x2e, 0x9f, 0x04, 0x28, 0x5b,
	0x62, 0x79, 0x4f, 0xfa, 0x45, 0x96, 0x66, 0xf0, 0xee, 0x13, 0x0f, 0x55, 0x69, 0xf9, 0x8c, 0x0a,
	0xd6, 0xb2, 0x0b, 0xd8, 0x91, 0x94, 0x1e, 0xc3, 0x4c, 0x37, 0x40, 0x06, 0xf8, 0x14, 0x5b, 0x49,
	0x6a, 0xc8, 0xa1, 0x39, 0x07, 0x57, 0xce, 0xdc, 0xa0, 0x99, 0x86, 0x45, 0x4f, 0xbe, 0x18, 0xfe,
	0xa5, 0x51, 0x79, 0x06, 0x56, 0x5f, 0xdf, 0xf2, 0x92, 0x73, 0x17, 0x66, 0xf4, 0x2d, 0x94, 0xe9,
	0xba, 0xe8, 0x23, 0x2a, 0xd2, 0x11, 0x7b, 0x3a, 0x2b, 0xaf, 0x22, 0x56, 0x36, 0xf5, 0x01, 0x1e,
	0x32, 0x7c, 0xda, 0x64, 0x54, 0x54, 0x11, 0x8f, 0x2f, 0x88, 0x97, 0x1e, 0xa0, 0x09, 0xa3, 0xe2,
	0x82, 0x78, 0xc9, 0x8a, 0xd4, 0xb8, 0xf2, 0x48, 0x3b, 0xee, 0xb1, 0x90, 0x8e, 0x57, 0xa1, 0xb8,
	0x5f, 0x3d, 0x76, 0x18, 0xd6, 0x9d, 0x8c, 0x1d, 0xec, 0x57, 0x8f, 0x6d, 0xac, 0x4b, 0x58, 0xe5,
	0x5f, 0x06, 0xcc, 0x4a, 0xf3, 0x7c, 0xa2, 0xcc, 0xc3, 0xd5, 0x5c, 0x92, 0x24, 0x33, 0xb9, 0x11,
	0x3d, 0xea, 0x4a, 0x90, 0x09, 0x7b, 0x5a, 0xcb, 0x73, 0xf9, 0xe1, 0xd7, 0x63, 0x91, 0xe6, 0x87,
	0x1c, 0x9b, 0xb7, 0x60, 0x4a, 0xfe, 0x66, 0x8c, 0x75, 0xa6, 0x4c, 0x4a, 0x69, 0xc7, 0x74, 0x01,
	0xc6, 0x7d, 0x44, 0xbd, 0x62, 0xfd, 0x57, 0x18, 0xf3, 0xf5, 0xae, 0xcc, 0x25, 0x98, 0x10, 0x8d,
	0x66, 0x78, 0x42, 0x5d, 0x12, 0xa8, 0x1b, 0x51, 0xd1, 0xee, 0x08, 0x2a, 0xdb, 0x30, 0x9d, 0xdd,
	0x8b, 0x8c, 0xc0, 0x0a, 0x14, 0x92, 0x15, 0x67, 0x03, 0xa0, 0x45, 0x2a, 0x00, 0x7f, 0x1b, 0x01,
	0xf3, 0x37, 0xb1, 0xbc, 0x9f, 0xe6, 0x6e, 0xb1, 0x37, 0x41, 0xdf, 0x03, 0x9c, 0x98, 0x60, 0x4d,
	0x9f, 0x56, 0xf1, 0xf9, 0x90, 0x0d, 0x4a, 0x78, 0x28, 0x65, 0x66, 0x15, 0x26, 0x42, 0x14, 0xae,
	0xe3, 0xb9, 0xc2, 0x55, 0x51, 0xe8, 0xba, 0x64, 0xf4, 0xb2, 0x6e, 0xbc, 0x44, 0xe1, 0xee, 0xba,
	0xc2, 0x7d, 0x3e, 0x64, 0x8f, 0x87, 0xc9, 0xb8, 0xf4, 0x27, 0x03, 0x60, 0x27, 0x8a, 0x98, 0x47,
	0xa8, 0x2b, 0xd0, 0x5c, 0x02, 0x90, 0x5f, 0xa9, 0x00, 0x7d, 0xe1, 0x5c, 0x24, 0x69, 0x32, 0x2e,
	0xa2, 0xf8, 0x2b, 0xf4, 0xc5, 0xd7, 0x39, 0x6d, 0x4b, 0x79, 0xed, 0x68, 0xbf, 0x91, 0xa5, 0xf9,
	0x24, 0x12, 0x22, 0x0a, 0x1d, 0x46, 0xea, 0x0d, 0x69, 0x3f, 0xa2, 0x10, 0x45, 0x2d, 0xb5, 0xa5,
	0xf0, 0xeb, 0x1e, 0x54, 0x4b, 0x1d, 0x43, 0x1e, 0xf5, 0x4d, 0xe9, 0x8f, 0x06, 0x8c, 0xa7, 0xeb,
	0x55, 0x45, 0x95, 0x7c, 0x9f, 0x66, 0xad, 0x1a, 0xcb, 0x24, 0xd1, 0x9f, 0xee, 0xf4, 0x9d, 0x40,
	0xcf, 0x24, 0xb6, 0x5d, 0x05, 0x8b, 0xb6, 0x1a, 0x9b, 0x5f, 0x66, 0xcf, 0x6d, 0x54, 0xc5, 0xea,
	0xee, 0x4f, 0xc4, 0xaa, 0x13, 0x92, 0xcc, 0x11, 0x3f, 0x9d, 0x68, 0xbf, 0x2e, 0x54, 0xfe, 0x6a,
	0xc0, 0x4c, 0xce, 0x2e, 0x79, 0x4f, 0x88, 0x19, 0x9e, 0x11, 0x3c, 0x77, 0xda, 0x46, 0x9d, 0x02,
	0x5f, 0xb4, 0xe7, 0x12, 0xed, 0x71, 0xaa, 0x54, 0xf5, 0x77, 0x1b, 0xae, 0x87, 0xe8, 0x91, 0x66,
	0xd8, 0x6d, 0xa4, 0xff, 0xe6, 0xd7, 0xb4, 0x32, 0x6f, 0xb3, 0x09, 0x73, 0x3c, 0x54, 0x6d, 0x57,
	0xde, 0x44, 0x6f, 0xdb, 0x54, 0xba, 0x9c, 0xc5, 0xf6, 0x9f, 0xaf, 0xc0, 0xb4, 0x9d, 0xbc, 0x46,
	0x3d, 0xd1, 0x8f, 0x51, 0xe6, 0x0e, 0x8c, 0x25, 0x2f, 0x49, 0x66, 0x29, 0x5f, 0xc7, 0xb2, 0xef,
	0x51, 0x25, 0xab, 0xaf, 0x2e, 0x0e, 0x5a, 0xeb, 0xc6, 0xa6, 0x61, 0xbe, 0x82, 0xc9, 0xdc, 0xfb,
	0x90, 0xb9, 0xfa, 0x9e, 0xa7, 0x23, 0x4d, 0x58, 0x7e, 0xff, 0xe3, 0x92, 0xf9, 0x0c, 0x26, 0xda,
	0x8f, 0x3d, 0xe6, 0x52, 0x16, 0xdc, 0xfd, 0x8e, 0x54, 0x2a, 0x0d, 0xd0, 0x4a, 0x9a, 0x17, 0x00,
	0x9d, 0xbb, 0xb6, 0xb9, 0x3c, 0xe8, 0x0e, 0xae, 0x89, 0x16, 0xdf, 0x73, 0x45, 0x5f, 0x37, 0xcc,
	0x1a, 0x5c, 0xeb, 0x53, 0x61, 0xcd, 0xdb, 0xff, 0x5f, 0xf9, 0x2f, 0xad, 0xfd, 0x24, 0x4e, 0x2e,
	0x38, 0x71, 0xd2, 0x55, 0x4d, 0x7b, 0x9d, 0xf4, 0x2f, 0xd0, 0xbd, 0x4e, 0xfa, 0x96, 0xe5, 0xe7,
	0x00, 0x9d, 0x3a, 0x95, 0x8f, 0x4a, 0x4f, 0x2d, 0xce, 0x47, 0xa5, 0xbb, 0xbc, 0xbd, 0x84, 0x42,
	0xe6, 0x2f, 0x60, 0x96, 0xdf, 0xff, 0x9f, 0x2a, 0x2d, 0x0d, 0xd4, 0xab, 0x10, 0x3f, 0xf5, 0xdf,
	0xbc, 0x2d, 0x0f, 0xfd, 0xf0, 0xb6, 0x3c, 0xf4, 0xe3, 0xdb, 0xb2, 0xf1, 0xbb, 0xcb, 0xb2, 0xf1,
	0x97, 0xcb, 0xb2, 0xf1, 0xcf, 0xcb, 0xb2, 0xf1, 0xe6, 0xb2, 0x6c, 0xfc, 0xfb, 0xb2, 0x6c, 0xfc,
	0xe7, 0xb2, 0x3c, 0xf4, 0xe3, 0x65, 0xd9, 0xf8, 0xc3, 0xbb, 0xf2, 0xd0, 0x9b, 0x77, 0xe5, 0xa1,
	0x1f, 0xde, 0x95, 0x87, 0xbe, 0xdd, 0xac, 0x13, 0xd1, 0x68, 0x9e, 0x6c, 0xd4, 0xa2, 0xf0, 0x5e,
	0xec, 0x72, 0x81, 0x01, 0x45, 0x95, 0xdd, 0xf7, 0xea, 0x91, 0x7a, 0x82, 0x55, 0x2f, 0xae, 0xf7,
	0x3a, 0xae, 0x4f, 0xae, 0x2a, 0xc9, 0xfd, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x2e, 0xf7, 0xf2,
	0x25, 0xa8, 0x15, 0x00, 0x00,
}

func (this *SessionRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionRequest)
	if !ok {
		that2, ok := that.(SessionRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IsPrimary != that1.IsPrimary {
		return false
	}
	return true
}
func (this *SessionReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SessionReply)
	if !ok {
		that2, ok := that.(SessionReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessID != that1.SessID {
		return false
	}
	return true
}
func (this *AcceptedNodesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptedNodesRequest)
	if !ok {
		that2, ok := that.(AcceptedNodesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *AcceptedNodesReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptedNodesReply)
	if !ok {
		that2, ok := that.(AcceptedNodesReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	return true
}
func (this *AcceptedNodesReply_Peer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AcceptedNodesReply_Peer)
	if !ok {
		that2, ok := that.(AcceptedNodesReply_Peer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NodeID != that1.NodeID {
		return false
	}
	return true
}
func (this *ConnectToRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectToRequest)
	if !ok {
		that2, ok := that.(ConnectToRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessID != that1.SessID {
		return false
	}
	if this.NodeID != that1.NodeID {
		return false
	}
	return true
}
func (this *ConnectToReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectToReply)
	if !ok {
		that2, ok := that.(ConnectToReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ProbeImageRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProbeImageRequest)
	if !ok {
		that2, ok := that.(ProbeImageRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Payload, that1.Payload) {
		return false
	}
	return true
}
func (this *ProbeImageReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProbeImageReply)
	if !ok {
		that2, ok := that.(ProbeImageReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DupeDetectionVersion != that1.DupeDetectionVersion {
		return false
	}
	if this.HashOfCandidateImg != that1.HashOfCandidateImg {
		return false
	}
	if this.AverageRarenessScore != that1.AverageRarenessScore {
		return false
	}
	if this.IsRareOnInternet != that1.IsRareOnInternet {
		return false
	}
	if this.MatchesFoundOnFirstPage != that1.MatchesFoundOnFirstPage {
		return false
	}
	if this.NumberOfPagesOfResults != that1.NumberOfPagesOfResults {
		return false
	}
	if this.UrlOfFirstMatchInPage != that1.UrlOfFirstMatchInPage {
		return false
	}
	if this.OpenNsfwScore != that1.OpenNsfwScore {
		return false
	}
	if !bytes.Equal(this.ZstdCompressedFingerprint, that1.ZstdCompressedFingerprint) {
		return false
	}
	if !this.AlternativeNsfwScore.Equal(that1.AlternativeNsfwScore) {
		return false
	}
	if !this.ImageHashes.Equal(that1.ImageHashes) {
		return false
	}
	if this.PerceptualHashOverlapCount != that1.PerceptualHashOverlapCount {
		return false
	}
	if this.NumberOfFingerprintsRequiringFurtherTesting_1 != that1.NumberOfFingerprintsRequiringFurtherTesting_1 {
		return false
	}
	if this.NumberOfFingerprintsRequiringFurtherTesting_2 != that1.NumberOfFingerprintsRequiringFurtherTesting_2 {
		return false
	}
	if this.NumberOfFingerprintsRequiringFurtherTesting_3 != that1.NumberOfFingerprintsRequiringFurtherTesting_3 {
		return false
	}
	if this.NumberOfFingerprintsRequiringFurtherTesting_4 != that1.NumberOfFingerprintsRequiringFurtherTesting_4 {
		return false
	}
	if this.NumberOfFingerprintsRequiringFurtherTesting_5 != that1.NumberOfFingerprintsRequiringFurtherTesting_5 {
		return false
	}
	if this.NumberOfFingerprintsRequiringFurtherTesting_6 != that1.NumberOfFingerprintsRequiringFurtherTesting_6 {
		return false
	}
	if this.NumberOfFingerprintsOfSuspectedDupes != that1.NumberOfFingerprintsOfSuspectedDupes {
		return false
	}
	if this.PearsonMax != that1.PearsonMax {
		return false
	}
	if this.SpearmanMax != that1.SpearmanMax {
		return false
	}
	if this.KendallMax != that1.KendallMax {
		return false
	}
	if this.HoeffdingMax != that1.HoeffdingMax {
		return false
	}
	if this.MutualInformationMax != that1.MutualInformationMax {
		return false
	}
	if this.HsicMax != that1.HsicMax {
		return false
	}
	if this.XgbimportanceMax != that1.XgbimportanceMax {
		return false
	}
	if this.PearsonTop_1BpsPercentile != that1.PearsonTop_1BpsPercentile {
		return false
	}
	if this.SpearmanTop_1BpsPercentile != that1.SpearmanTop_1BpsPercentile {
		return false
	}
	if this.KendallTop_1BpsPercentile != that1.KendallTop_1BpsPercentile {
		return false
	}
	if this.HoeffdingTop_10BpsPercentile != that1.HoeffdingTop_10BpsPercentile {
		return false
	}
	if this.MutualInformationTop_100BpsPercentile != that1.MutualInformationTop_100BpsPercentile {
		return false
	}
	if this.HsicTop_100BpsPercentile != that1.HsicTop_100BpsPercentile {
		return false
	}
	if this.XgbimportanceTop_100BpsPercentile != that1.XgbimportanceTop_100BpsPercentile {
		return false
	}
	if this.CombinedRarenessScore != that1.CombinedRarenessScore {
		return false
	}
	if this.XgboostPredictedRarenessScore != that1.XgboostPredictedRarenessScore {
		return false
	}
	if this.NnPredictedRarenessScore != that1.NnPredictedRarenessScore {
		return false
	}
	if this.OverallAverageRarenessScore != that1.OverallAverageRarenessScore {
		return false
	}
	if this.IsLikelyDupe != that1.IsLikelyDupe {
		return false
	}
	return true
}
func (this *ProbeImageReply_AlternativeNSFWScore) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProbeImageReply_AlternativeNSFWScore)
	if !ok {
		that2, ok := that.(ProbeImageReply_AlternativeNSFWScore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Drawing != that1.Drawing {
		return false
	}
	if this.Hentai != that1.Hentai {
		return false
	}
	if this.Neutral != that1.Neutral {
		return false
	}
	if this.Porn != that1.Porn {
		return false
	}
	if this.Sexy != that1.Sexy {
		return false
	}
	return true
}
func (this *ProbeImageReply_ImageHashes) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ProbeImageReply_ImageHashes)
	if !ok {
		that2, ok := that.(ProbeImageReply_ImageHashes)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PerceptualHash != that1.PerceptualHash {
		return false
	}
	if this.AverageHash != that1.AverageHash {
		return false
	}
	if this.DifferenceHash != that1.DifferenceHash {
		return false
	}
	if this.PDQHash != that1.PDQHash {
		return false
	}
	if this.NeuralHash != that1.NeuralHash {
		return false
	}
	return true
}
func (this *EncoderParameters) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncoderParameters)
	if !ok {
		that2, ok := that.(EncoderParameters)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Oti, that1.Oti) {
		return false
	}
	return true
}
func (this *SendSignedNFTTicketRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendSignedNFTTicketRequest)
	if !ok {
		that2, ok := that.(SendSignedNFTTicketRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.NftTicket, that1.NftTicket) {
		return false
	}
	if !bytes.Equal(this.CreatorSignature, that1.CreatorSignature) {
		return false
	}
	if this.Key1 != that1.Key1 {
		return false
	}
	if this.Key2 != that1.Key2 {
		return false
	}
	if !this.EncodeParameters.Equal(that1.EncodeParameters) {
		return false
	}
	if len(this.EncodeFiles) != len(that1.EncodeFiles) {
		return false
	}
	for i := range this.EncodeFiles {
		if !bytes.Equal(this.EncodeFiles[i], that1.EncodeFiles[i]) {
			return false
		}
	}
	return true
}
func (this *SendSignedNFTTicketReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendSignedNFTTicketReply)
	if !ok {
		that2, ok := that.(SendSignedNFTTicketReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RegistrationFee != that1.RegistrationFee {
		return false
	}
	return true
}
func (this *SendPreBurntFeeTxidRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPreBurntFeeTxidRequest)
	if !ok {
		that2, ok := that.(SendPreBurntFeeTxidRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Txid != that1.Txid {
		return false
	}
	return true
}
func (this *SendPreBurntFeeTxidReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendPreBurntFeeTxidReply)
	if !ok {
		that2, ok := that.(SendPreBurntFeeTxidReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.NFTRegTxid != that1.NFTRegTxid {
		return false
	}
	return true
}
func (this *SendTicketRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendTicketRequest)
	if !ok {
		that2, ok := that.(SendTicketRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Ticket, that1.Ticket) {
		return false
	}
	if this.TicketSignature != that1.TicketSignature {
		return false
	}
	if this.Fgpt != that1.Fgpt {
		return false
	}
	if this.FgptSignature != that1.FgptSignature {
		return false
	}
	if this.FeeTxid != that1.FeeTxid {
		return false
	}
	if !bytes.Equal(this.Thumbnail, that1.Thumbnail) {
		return false
	}
	return true
}
func (this *SendTicketReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendTicketReply)
	if !ok {
		that2, ok := that.(SendTicketReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TicketTxid != that1.TicketTxid {
		return false
	}
	return true
}
func (this *UploadImageRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadImageRequest)
	if !ok {
		that2, ok := that.(UploadImageRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Payload == nil {
		if this.Payload != nil {
			return false
		}
	} else if this.Payload == nil {
		return false
	} else if !this.Payload.Equal(that1.Payload) {
		return false
	}
	return true
}
func (this *UploadImageRequest_ImagePiece) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadImageRequest_ImagePiece)
	if !ok {
		that2, ok := that.(UploadImageRequest_ImagePiece)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.ImagePiece, that1.ImagePiece) {
		return false
	}
	return true
}
func (this *UploadImageRequest_MetaData_) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadImageRequest_MetaData_)
	if !ok {
		that2, ok := that.(UploadImageRequest_MetaData_)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MetaData.Equal(that1.MetaData) {
		return false
	}
	return true
}
func (this *UploadImageRequest_Coordinate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadImageRequest_Coordinate)
	if !ok {
		that2, ok := that.(UploadImageRequest_Coordinate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopLeftX != that1.TopLeftX {
		return false
	}
	if this.TopLeftY != that1.TopLeftY {
		return false
	}
	if this.BottomRightX != that1.BottomRightX {
		return false
	}
	if this.BottomRightY != that1.BottomRightY {
		return false
	}
	return true
}
func (this *UploadImageRequest_MetaData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadImageRequest_MetaData)
	if !ok {
		that2, ok := that.(UploadImageRequest_MetaData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Size_ != that1.Size_ {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	if !bytes.Equal(this.Hash, that1.Hash) {
		return false
	}
	if !this.Thumbnail.Equal(that1.Thumbnail) {
		return false
	}
	return true
}
func (this *UploadImageReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadImageReply)
	if !ok {
		that2, ok := that.(UploadImageReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.PreviewThumbnailHash, that1.PreviewThumbnailHash) {
		return false
	}
	if !bytes.Equal(this.MediumThumbnailHash, that1.MediumThumbnailHash) {
		return false
	}
	if !bytes.Equal(this.SmallThumbnailHash, that1.SmallThumbnailHash) {
		return false
	}
	return true
}
func (this *SessionRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.SessionRequest{")
	s = append(s, "IsPrimary: "+fmt.Sprintf("%#v", this.IsPrimary)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.SessionReply{")
	s = append(s, "SessID: "+fmt.Sprintf("%#v", this.SessID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptedNodesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&walletnode.AcceptedNodesRequest{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptedNodesReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.AcceptedNodesReply{")
	if this.Peers != nil {
		s = append(s, "Peers: "+fmt.Sprintf("%#v", this.Peers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AcceptedNodesReply_Peer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.AcceptedNodesReply_Peer{")
	s = append(s, "NodeID: "+fmt.Sprintf("%#v", this.NodeID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConnectToRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&walletnode.ConnectToRequest{")
	s = append(s, "SessID: "+fmt.Sprintf("%#v", this.SessID)+",\n")
	s = append(s, "NodeID: "+fmt.Sprintf("%#v", this.NodeID)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConnectToReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&walletnode.ConnectToReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeImageRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.ProbeImageRequest{")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeImageReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 42)
	s = append(s, "&walletnode.ProbeImageReply{")
	s = append(s, "DupeDetectionVersion: "+fmt.Sprintf("%#v", this.DupeDetectionVersion)+",\n")
	s = append(s, "HashOfCandidateImg: "+fmt.Sprintf("%#v", this.HashOfCandidateImg)+",\n")
	s = append(s, "AverageRarenessScore: "+fmt.Sprintf("%#v", this.AverageRarenessScore)+",\n")
	s = append(s, "IsRareOnInternet: "+fmt.Sprintf("%#v", this.IsRareOnInternet)+",\n")
	s = append(s, "MatchesFoundOnFirstPage: "+fmt.Sprintf("%#v", this.MatchesFoundOnFirstPage)+",\n")
	s = append(s, "NumberOfPagesOfResults: "+fmt.Sprintf("%#v", this.NumberOfPagesOfResults)+",\n")
	s = append(s, "UrlOfFirstMatchInPage: "+fmt.Sprintf("%#v", this.UrlOfFirstMatchInPage)+",\n")
	s = append(s, "OpenNsfwScore: "+fmt.Sprintf("%#v", this.OpenNsfwScore)+",\n")
	s = append(s, "ZstdCompressedFingerprint: "+fmt.Sprintf("%#v", this.ZstdCompressedFingerprint)+",\n")
	if this.AlternativeNsfwScore != nil {
		s = append(s, "AlternativeNsfwScore: "+fmt.Sprintf("%#v", this.AlternativeNsfwScore)+",\n")
	}
	if this.ImageHashes != nil {
		s = append(s, "ImageHashes: "+fmt.Sprintf("%#v", this.ImageHashes)+",\n")
	}
	s = append(s, "PerceptualHashOverlapCount: "+fmt.Sprintf("%#v", this.PerceptualHashOverlapCount)+",\n")
	s = append(s, "NumberOfFingerprintsRequiringFurtherTesting_1: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsRequiringFurtherTesting_1)+",\n")
	s = append(s, "NumberOfFingerprintsRequiringFurtherTesting_2: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsRequiringFurtherTesting_2)+",\n")
	s = append(s, "NumberOfFingerprintsRequiringFurtherTesting_3: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsRequiringFurtherTesting_3)+",\n")
	s = append(s, "NumberOfFingerprintsRequiringFurtherTesting_4: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsRequiringFurtherTesting_4)+",\n")
	s = append(s, "NumberOfFingerprintsRequiringFurtherTesting_5: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsRequiringFurtherTesting_5)+",\n")
	s = append(s, "NumberOfFingerprintsRequiringFurtherTesting_6: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsRequiringFurtherTesting_6)+",\n")
	s = append(s, "NumberOfFingerprintsOfSuspectedDupes: "+fmt.Sprintf("%#v", this.NumberOfFingerprintsOfSuspectedDupes)+",\n")
	s = append(s, "PearsonMax: "+fmt.Sprintf("%#v", this.PearsonMax)+",\n")
	s = append(s, "SpearmanMax: "+fmt.Sprintf("%#v", this.SpearmanMax)+",\n")
	s = append(s, "KendallMax: "+fmt.Sprintf("%#v", this.KendallMax)+",\n")
	s = append(s, "HoeffdingMax: "+fmt.Sprintf("%#v", this.HoeffdingMax)+",\n")
	s = append(s, "MutualInformationMax: "+fmt.Sprintf("%#v", this.MutualInformationMax)+",\n")
	s = append(s, "HsicMax: "+fmt.Sprintf("%#v", this.HsicMax)+",\n")
	s = append(s, "XgbimportanceMax: "+fmt.Sprintf("%#v", this.XgbimportanceMax)+",\n")
	s = append(s, "PearsonTop_1BpsPercentile: "+fmt.Sprintf("%#v", this.PearsonTop_1BpsPercentile)+",\n")
	s = append(s, "SpearmanTop_1BpsPercentile: "+fmt.Sprintf("%#v", this.SpearmanTop_1BpsPercentile)+",\n")
	s = append(s, "KendallTop_1BpsPercentile: "+fmt.Sprintf("%#v", this.KendallTop_1BpsPercentile)+",\n")
	s = append(s, "HoeffdingTop_10BpsPercentile: "+fmt.Sprintf("%#v", this.HoeffdingTop_10BpsPercentile)+",\n")
	s = append(s, "MutualInformationTop_100BpsPercentile: "+fmt.Sprintf("%#v", this.MutualInformationTop_100BpsPercentile)+",\n")
	s = append(s, "HsicTop_100BpsPercentile: "+fmt.Sprintf("%#v", this.HsicTop_100BpsPercentile)+",\n")
	s = append(s, "XgbimportanceTop_100BpsPercentile: "+fmt.Sprintf("%#v", this.XgbimportanceTop_100BpsPercentile)+",\n")
	s = append(s, "CombinedRarenessScore: "+fmt.Sprintf("%#v", this.CombinedRarenessScore)+",\n")
	s = append(s, "XgboostPredictedRarenessScore: "+fmt.Sprintf("%#v", this.XgboostPredictedRarenessScore)+",\n")
	s = append(s, "NnPredictedRarenessScore: "+fmt.Sprintf("%#v", this.NnPredictedRarenessScore)+",\n")
	s = append(s, "OverallAverageRarenessScore: "+fmt.Sprintf("%#v", this.OverallAverageRarenessScore)+",\n")
	s = append(s, "IsLikelyDupe: "+fmt.Sprintf("%#v", this.IsLikelyDupe)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeImageReply_AlternativeNSFWScore) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&walletnode.ProbeImageReply_AlternativeNSFWScore{")
	s = append(s, "Drawing: "+fmt.Sprintf("%#v", this.Drawing)+",\n")
	s = append(s, "Hentai: "+fmt.Sprintf("%#v", this.Hentai)+",\n")
	s = append(s, "Neutral: "+fmt.Sprintf("%#v", this.Neutral)+",\n")
	s = append(s, "Porn: "+fmt.Sprintf("%#v", this.Porn)+",\n")
	s = append(s, "Sexy: "+fmt.Sprintf("%#v", this.Sexy)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ProbeImageReply_ImageHashes) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&walletnode.ProbeImageReply_ImageHashes{")
	s = append(s, "PerceptualHash: "+fmt.Sprintf("%#v", this.PerceptualHash)+",\n")
	s = append(s, "AverageHash: "+fmt.Sprintf("%#v", this.AverageHash)+",\n")
	s = append(s, "DifferenceHash: "+fmt.Sprintf("%#v", this.DifferenceHash)+",\n")
	s = append(s, "PDQHash: "+fmt.Sprintf("%#v", this.PDQHash)+",\n")
	s = append(s, "NeuralHash: "+fmt.Sprintf("%#v", this.NeuralHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EncoderParameters) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.EncoderParameters{")
	s = append(s, "Oti: "+fmt.Sprintf("%#v", this.Oti)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendSignedNFTTicketRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&walletnode.SendSignedNFTTicketRequest{")
	s = append(s, "NftTicket: "+fmt.Sprintf("%#v", this.NftTicket)+",\n")
	s = append(s, "CreatorSignature: "+fmt.Sprintf("%#v", this.CreatorSignature)+",\n")
	s = append(s, "Key1: "+fmt.Sprintf("%#v", this.Key1)+",\n")
	s = append(s, "Key2: "+fmt.Sprintf("%#v", this.Key2)+",\n")
	if this.EncodeParameters != nil {
		s = append(s, "EncodeParameters: "+fmt.Sprintf("%#v", this.EncodeParameters)+",\n")
	}
	keysForEncodeFiles := make([]string, 0, len(this.EncodeFiles))
	for k, _ := range this.EncodeFiles {
		keysForEncodeFiles = append(keysForEncodeFiles, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEncodeFiles)
	mapStringForEncodeFiles := "map[string][]byte{"
	for _, k := range keysForEncodeFiles {
		mapStringForEncodeFiles += fmt.Sprintf("%#v: %#v,", k, this.EncodeFiles[k])
	}
	mapStringForEncodeFiles += "}"
	if this.EncodeFiles != nil {
		s = append(s, "EncodeFiles: "+mapStringForEncodeFiles+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendSignedNFTTicketReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.SendSignedNFTTicketReply{")
	s = append(s, "RegistrationFee: "+fmt.Sprintf("%#v", this.RegistrationFee)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPreBurntFeeTxidRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.SendPreBurntFeeTxidRequest{")
	s = append(s, "Txid: "+fmt.Sprintf("%#v", this.Txid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendPreBurntFeeTxidReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.SendPreBurntFeeTxidReply{")
	s = append(s, "NFTRegTxid: "+fmt.Sprintf("%#v", this.NFTRegTxid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendTicketRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&walletnode.SendTicketRequest{")
	s = append(s, "Ticket: "+fmt.Sprintf("%#v", this.Ticket)+",\n")
	s = append(s, "TicketSignature: "+fmt.Sprintf("%#v", this.TicketSignature)+",\n")
	s = append(s, "Fgpt: "+fmt.Sprintf("%#v", this.Fgpt)+",\n")
	s = append(s, "FgptSignature: "+fmt.Sprintf("%#v", this.FgptSignature)+",\n")
	s = append(s, "FeeTxid: "+fmt.Sprintf("%#v", this.FeeTxid)+",\n")
	s = append(s, "Thumbnail: "+fmt.Sprintf("%#v", this.Thumbnail)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendTicketReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&walletnode.SendTicketReply{")
	s = append(s, "TicketTxid: "+fmt.Sprintf("%#v", this.TicketTxid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadImageRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&walletnode.UploadImageRequest{")
	if this.Payload != nil {
		s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadImageRequest_ImagePiece) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&walletnode.UploadImageRequest_ImagePiece{` +
		`ImagePiece:` + fmt.Sprintf("%#v", this.ImagePiece) + `}`}, ", ")
	return s
}
func (this *UploadImageRequest_MetaData_) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&walletnode.UploadImageRequest_MetaData_{` +
		`MetaData:` + fmt.Sprintf("%#v", this.MetaData) + `}`}, ", ")
	return s
}
func (this *UploadImageRequest_Coordinate) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&walletnode.UploadImageRequest_Coordinate{")
	s = append(s, "TopLeftX: "+fmt.Sprintf("%#v", this.TopLeftX)+",\n")
	s = append(s, "TopLeftY: "+fmt.Sprintf("%#v", this.TopLeftY)+",\n")
	s = append(s, "BottomRightX: "+fmt.Sprintf("%#v", this.BottomRightX)+",\n")
	s = append(s, "BottomRightY: "+fmt.Sprintf("%#v", this.BottomRightY)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadImageRequest_MetaData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&walletnode.UploadImageRequest_MetaData{")
	s = append(s, "Size_: "+fmt.Sprintf("%#v", this.Size_)+",\n")
	s = append(s, "Format: "+fmt.Sprintf("%#v", this.Format)+",\n")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	if this.Thumbnail != nil {
		s = append(s, "Thumbnail: "+fmt.Sprintf("%#v", this.Thumbnail)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UploadImageReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&walletnode.UploadImageReply{")
	s = append(s, "PreviewThumbnailHash: "+fmt.Sprintf("%#v", this.PreviewThumbnailHash)+",\n")
	s = append(s, "MediumThumbnailHash: "+fmt.Sprintf("%#v", this.MediumThumbnailHash)+",\n")
	s = append(s, "SmallThumbnailHash: "+fmt.Sprintf("%#v", this.SmallThumbnailHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringRegisterArtwork(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *SessionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsPrimary {
		i--
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SessID) > 0 {
		i -= len(m.SessID)
		copy(dAtA[i:], m.SessID)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.SessID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptedNodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptedNodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptedNodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AcceptedNodesReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptedNodesReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptedNodesReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for iNdEx := len(m.Peers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Peers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRegisterArtwork(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AcceptedNodesReply_Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptedNodesReply_Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptedNodesReply_Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConnectToRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectToRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectToRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeID) > 0 {
		i -= len(m.NodeID)
		copy(dAtA[i:], m.NodeID)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.NodeID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessID) > 0 {
		i -= len(m.SessID)
		copy(dAtA[i:], m.SessID)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.SessID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConnectToReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectToReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectToReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ProbeImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProbeImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProbeImageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeImageReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProbeImageReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsLikelyDupe {
		i--
		if m.IsLikelyDupe {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.OverallAverageRarenessScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OverallAverageRarenessScore))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xad
	}
	if m.NnPredictedRarenessScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.NnPredictedRarenessScore))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa5
	}
	if m.XgboostPredictedRarenessScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.XgboostPredictedRarenessScore))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9d
	}
	if m.CombinedRarenessScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CombinedRarenessScore))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x95
	}
	if m.XgbimportanceTop_100BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.XgbimportanceTop_100BpsPercentile))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8d
	}
	if m.HsicTop_100BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HsicTop_100BpsPercentile))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x85
	}
	if m.MutualInformationTop_100BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MutualInformationTop_100BpsPercentile))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfd
	}
	if m.HoeffdingTop_10BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HoeffdingTop_10BpsPercentile))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf5
	}
	if m.KendallTop_1BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.KendallTop_1BpsPercentile))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xed
	}
	if m.SpearmanTop_1BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SpearmanTop_1BpsPercentile))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.PearsonTop_1BpsPercentile != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PearsonTop_1BpsPercentile))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xdd
	}
	if m.XgbimportanceMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.XgbimportanceMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd5
	}
	if m.HsicMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HsicMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xcd
	}
	if m.MutualInformationMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MutualInformationMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc5
	}
	if m.HoeffdingMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HoeffdingMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.KendallMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.KendallMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.SpearmanMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SpearmanMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xad
	}
	if m.PearsonMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PearsonMax))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.NumberOfFingerprintsOfSuspectedDupes != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsOfSuspectedDupes))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_6 != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsRequiringFurtherTesting_6))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_5 != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsRequiringFurtherTesting_5))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_4 != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsRequiringFurtherTesting_4))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_3 != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsRequiringFurtherTesting_3))
		i--
		dAtA[i] = 0x78
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_2 != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsRequiringFurtherTesting_2))
		i--
		dAtA[i] = 0x70
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_1 != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfFingerprintsRequiringFurtherTesting_1))
		i--
		dAtA[i] = 0x68
	}
	if m.PerceptualHashOverlapCount != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.PerceptualHashOverlapCount))
		i--
		dAtA[i] = 0x60
	}
	if m.ImageHashes != nil {
		{
			size, err := m.ImageHashes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.AlternativeNsfwScore != nil {
		{
			size, err := m.AlternativeNsfwScore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.ZstdCompressedFingerprint) > 0 {
		i -= len(m.ZstdCompressedFingerprint)
		copy(dAtA[i:], m.ZstdCompressedFingerprint)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.ZstdCompressedFingerprint)))
		i--
		dAtA[i] = 0x4a
	}
	if m.OpenNsfwScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OpenNsfwScore))))
		i--
		dAtA[i] = 0x45
	}
	if len(m.UrlOfFirstMatchInPage) > 0 {
		i -= len(m.UrlOfFirstMatchInPage)
		copy(dAtA[i:], m.UrlOfFirstMatchInPage)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.UrlOfFirstMatchInPage)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NumberOfPagesOfResults != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.NumberOfPagesOfResults))
		i--
		dAtA[i] = 0x30
	}
	if m.MatchesFoundOnFirstPage != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.MatchesFoundOnFirstPage))
		i--
		dAtA[i] = 0x28
	}
	if m.IsRareOnInternet {
		i--
		if m.IsRareOnInternet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AverageRarenessScore != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AverageRarenessScore))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.HashOfCandidateImg) > 0 {
		i -= len(m.HashOfCandidateImg)
		copy(dAtA[i:], m.HashOfCandidateImg)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.HashOfCandidateImg)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DupeDetectionVersion) > 0 {
		i -= len(m.DupeDetectionVersion)
		copy(dAtA[i:], m.DupeDetectionVersion)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.DupeDetectionVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProbeImageReply_AlternativeNSFWScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeImageReply_AlternativeNSFWScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProbeImageReply_AlternativeNSFWScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sexy != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Sexy))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Porn != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Porn))))
		i--
		dAtA[i] = 0x25
	}
	if m.Neutral != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Neutral))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Hentai != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Hentai))))
		i--
		dAtA[i] = 0x15
	}
	if m.Drawing != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Drawing))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *ProbeImageReply_ImageHashes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProbeImageReply_ImageHashes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProbeImageReply_ImageHashes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NeuralHash) > 0 {
		i -= len(m.NeuralHash)
		copy(dAtA[i:], m.NeuralHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.NeuralHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PDQHash) > 0 {
		i -= len(m.PDQHash)
		copy(dAtA[i:], m.PDQHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.PDQHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DifferenceHash) > 0 {
		i -= len(m.DifferenceHash)
		copy(dAtA[i:], m.DifferenceHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.DifferenceHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AverageHash) > 0 {
		i -= len(m.AverageHash)
		copy(dAtA[i:], m.AverageHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.AverageHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PerceptualHash) > 0 {
		i -= len(m.PerceptualHash)
		copy(dAtA[i:], m.PerceptualHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.PerceptualHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncoderParameters) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncoderParameters) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncoderParameters) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Oti) > 0 {
		i -= len(m.Oti)
		copy(dAtA[i:], m.Oti)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Oti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendSignedNFTTicketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSignedNFTTicketRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendSignedNFTTicketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncodeFiles) > 0 {
		for k := range m.EncodeFiles {
			v := m.EncodeFiles[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.EncodeParameters != nil {
		{
			size, err := m.EncodeParameters.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Key2) > 0 {
		i -= len(m.Key2)
		copy(dAtA[i:], m.Key2)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Key2)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key1) > 0 {
		i -= len(m.Key1)
		copy(dAtA[i:], m.Key1)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Key1)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CreatorSignature) > 0 {
		i -= len(m.CreatorSignature)
		copy(dAtA[i:], m.CreatorSignature)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.CreatorSignature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NftTicket) > 0 {
		i -= len(m.NftTicket)
		copy(dAtA[i:], m.NftTicket)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.NftTicket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendSignedNFTTicketReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSignedNFTTicketReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendSignedNFTTicketReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegistrationFee != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.RegistrationFee))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SendPreBurntFeeTxidRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPreBurntFeeTxidRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendPreBurntFeeTxidRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendPreBurntFeeTxidReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPreBurntFeeTxidReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendPreBurntFeeTxidReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NFTRegTxid) > 0 {
		i -= len(m.NFTRegTxid)
		copy(dAtA[i:], m.NFTRegTxid)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.NFTRegTxid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendTicketRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTicketRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendTicketRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FeeTxid) > 0 {
		i -= len(m.FeeTxid)
		copy(dAtA[i:], m.FeeTxid)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.FeeTxid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.FgptSignature) > 0 {
		i -= len(m.FgptSignature)
		copy(dAtA[i:], m.FgptSignature)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.FgptSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Fgpt) > 0 {
		i -= len(m.Fgpt)
		copy(dAtA[i:], m.Fgpt)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Fgpt)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TicketSignature) > 0 {
		i -= len(m.TicketSignature)
		copy(dAtA[i:], m.TicketSignature)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.TicketSignature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Ticket) > 0 {
		i -= len(m.Ticket)
		copy(dAtA[i:], m.Ticket)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Ticket)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SendTicketReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendTicketReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SendTicketReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TicketTxid) > 0 {
		i -= len(m.TicketTxid)
		copy(dAtA[i:], m.TicketTxid)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.TicketTxid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UploadImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadImageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadImageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *UploadImageRequest_ImagePiece) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadImageRequest_ImagePiece) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ImagePiece != nil {
		i -= len(m.ImagePiece)
		copy(dAtA[i:], m.ImagePiece)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.ImagePiece)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *UploadImageRequest_MetaData_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadImageRequest_MetaData_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MetaData != nil {
		{
			size, err := m.MetaData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *UploadImageRequest_Coordinate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadImageRequest_Coordinate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadImageRequest_Coordinate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BottomRightY != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.BottomRightY))
		i--
		dAtA[i] = 0x20
	}
	if m.BottomRightX != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.BottomRightX))
		i--
		dAtA[i] = 0x18
	}
	if m.TopLeftY != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.TopLeftY))
		i--
		dAtA[i] = 0x10
	}
	if m.TopLeftX != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.TopLeftX))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadImageRequest_MetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadImageRequest_MetaData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadImageRequest_MetaData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRegisterArtwork(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x12
	}
	if m.Size_ != 0 {
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadImageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadImageReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadImageReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SmallThumbnailHash) > 0 {
		i -= len(m.SmallThumbnailHash)
		copy(dAtA[i:], m.SmallThumbnailHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.SmallThumbnailHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MediumThumbnailHash) > 0 {
		i -= len(m.MediumThumbnailHash)
		copy(dAtA[i:], m.MediumThumbnailHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.MediumThumbnailHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PreviewThumbnailHash) > 0 {
		i -= len(m.PreviewThumbnailHash)
		copy(dAtA[i:], m.PreviewThumbnailHash)
		i = encodeVarintRegisterArtwork(dAtA, i, uint64(len(m.PreviewThumbnailHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRegisterArtwork(dAtA []byte, offset int, v uint64) int {
	offset -= sovRegisterArtwork(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SessionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsPrimary {
		n += 2
	}
	return n
}

func (m *SessionReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessID)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *AcceptedNodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AcceptedNodesReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovRegisterArtwork(uint64(l))
		}
	}
	return n
}

func (m *AcceptedNodesReply_Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *ConnectToRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessID)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.NodeID)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *ConnectToReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ProbeImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *ProbeImageReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DupeDetectionVersion)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.HashOfCandidateImg)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.AverageRarenessScore != 0 {
		n += 5
	}
	if m.IsRareOnInternet {
		n += 2
	}
	if m.MatchesFoundOnFirstPage != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.MatchesFoundOnFirstPage))
	}
	if m.NumberOfPagesOfResults != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.NumberOfPagesOfResults))
	}
	l = len(m.UrlOfFirstMatchInPage)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.OpenNsfwScore != 0 {
		n += 5
	}
	l = len(m.ZstdCompressedFingerprint)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.AlternativeNsfwScore != nil {
		l = m.AlternativeNsfwScore.Size()
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.ImageHashes != nil {
		l = m.ImageHashes.Size()
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.PerceptualHashOverlapCount != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.PerceptualHashOverlapCount))
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_1 != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsRequiringFurtherTesting_1))
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_2 != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsRequiringFurtherTesting_2))
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_3 != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsRequiringFurtherTesting_3))
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_4 != 0 {
		n += 2 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsRequiringFurtherTesting_4))
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_5 != 0 {
		n += 2 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsRequiringFurtherTesting_5))
	}
	if m.NumberOfFingerprintsRequiringFurtherTesting_6 != 0 {
		n += 2 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsRequiringFurtherTesting_6))
	}
	if m.NumberOfFingerprintsOfSuspectedDupes != 0 {
		n += 2 + sovRegisterArtwork(uint64(m.NumberOfFingerprintsOfSuspectedDupes))
	}
	if m.PearsonMax != 0 {
		n += 6
	}
	if m.SpearmanMax != 0 {
		n += 6
	}
	if m.KendallMax != 0 {
		n += 6
	}
	if m.HoeffdingMax != 0 {
		n += 6
	}
	if m.MutualInformationMax != 0 {
		n += 6
	}
	if m.HsicMax != 0 {
		n += 6
	}
	if m.XgbimportanceMax != 0 {
		n += 6
	}
	if m.PearsonTop_1BpsPercentile != 0 {
		n += 6
	}
	if m.SpearmanTop_1BpsPercentile != 0 {
		n += 6
	}
	if m.KendallTop_1BpsPercentile != 0 {
		n += 6
	}
	if m.HoeffdingTop_10BpsPercentile != 0 {
		n += 6
	}
	if m.MutualInformationTop_100BpsPercentile != 0 {
		n += 6
	}
	if m.HsicTop_100BpsPercentile != 0 {
		n += 6
	}
	if m.XgbimportanceTop_100BpsPercentile != 0 {
		n += 6
	}
	if m.CombinedRarenessScore != 0 {
		n += 6
	}
	if m.XgboostPredictedRarenessScore != 0 {
		n += 6
	}
	if m.NnPredictedRarenessScore != 0 {
		n += 6
	}
	if m.OverallAverageRarenessScore != 0 {
		n += 6
	}
	if m.IsLikelyDupe {
		n += 3
	}
	return n
}

func (m *ProbeImageReply_AlternativeNSFWScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Drawing != 0 {
		n += 5
	}
	if m.Hentai != 0 {
		n += 5
	}
	if m.Neutral != 0 {
		n += 5
	}
	if m.Porn != 0 {
		n += 5
	}
	if m.Sexy != 0 {
		n += 5
	}
	return n
}

func (m *ProbeImageReply_ImageHashes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PerceptualHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.AverageHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.DifferenceHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.PDQHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.NeuralHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *EncoderParameters) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Oti)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *SendSignedNFTTicketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NftTicket)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.CreatorSignature)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.Key1)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.Key2)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.EncodeParameters != nil {
		l = m.EncodeParameters.Size()
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if len(m.EncodeFiles) > 0 {
		for k, v := range m.EncodeFiles {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovRegisterArtwork(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovRegisterArtwork(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovRegisterArtwork(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SendSignedNFTTicketReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegistrationFee != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.RegistrationFee))
	}
	return n
}

func (m *SendPreBurntFeeTxidRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *SendPreBurntFeeTxidReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NFTRegTxid)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *SendTicketRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.TicketSignature)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.Fgpt)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.FgptSignature)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.FeeTxid)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *SendTicketReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TicketTxid)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *UploadImageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *UploadImageRequest_ImagePiece) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ImagePiece != nil {
		l = len(m.ImagePiece)
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}
func (m *UploadImageRequest_MetaData_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MetaData != nil {
		l = m.MetaData.Size()
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}
func (m *UploadImageRequest_Coordinate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopLeftX != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.TopLeftX))
	}
	if m.TopLeftY != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.TopLeftY))
	}
	if m.BottomRightX != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.BottomRightX))
	}
	if m.BottomRightY != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.BottomRightY))
	}
	return n
}

func (m *UploadImageRequest_MetaData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovRegisterArtwork(uint64(m.Size_))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func (m *UploadImageReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PreviewThumbnailHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.MediumThumbnailHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	l = len(m.SmallThumbnailHash)
	if l > 0 {
		n += 1 + l + sovRegisterArtwork(uint64(l))
	}
	return n
}

func sovRegisterArtwork(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRegisterArtwork(x uint64) (n int) {
	return sovRegisterArtwork(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SessionRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionRequest{`,
		`IsPrimary:` + fmt.Sprintf("%v", this.IsPrimary) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SessionReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SessionReply{`,
		`SessID:` + fmt.Sprintf("%v", this.SessID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptedNodesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptedNodesRequest{`,
		`}`,
	}, "")
	return s
}
func (this *AcceptedNodesReply) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPeers := "[]*AcceptedNodesReply_Peer{"
	for _, f := range this.Peers {
		repeatedStringForPeers += strings.Replace(fmt.Sprintf("%v", f), "AcceptedNodesReply_Peer", "AcceptedNodesReply_Peer", 1) + ","
	}
	repeatedStringForPeers += "}"
	s := strings.Join([]string{`&AcceptedNodesReply{`,
		`Peers:` + repeatedStringForPeers + `,`,
		`}`,
	}, "")
	return s
}
func (this *AcceptedNodesReply_Peer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AcceptedNodesReply_Peer{`,
		`NodeID:` + fmt.Sprintf("%v", this.NodeID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConnectToRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConnectToRequest{`,
		`SessID:` + fmt.Sprintf("%v", this.SessID) + `,`,
		`NodeID:` + fmt.Sprintf("%v", this.NodeID) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConnectToReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConnectToReply{`,
		`}`,
	}, "")
	return s
}
func (this *ProbeImageRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeImageRequest{`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeImageReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeImageReply{`,
		`DupeDetectionVersion:` + fmt.Sprintf("%v", this.DupeDetectionVersion) + `,`,
		`HashOfCandidateImg:` + fmt.Sprintf("%v", this.HashOfCandidateImg) + `,`,
		`AverageRarenessScore:` + fmt.Sprintf("%v", this.AverageRarenessScore) + `,`,
		`IsRareOnInternet:` + fmt.Sprintf("%v", this.IsRareOnInternet) + `,`,
		`MatchesFoundOnFirstPage:` + fmt.Sprintf("%v", this.MatchesFoundOnFirstPage) + `,`,
		`NumberOfPagesOfResults:` + fmt.Sprintf("%v", this.NumberOfPagesOfResults) + `,`,
		`UrlOfFirstMatchInPage:` + fmt.Sprintf("%v", this.UrlOfFirstMatchInPage) + `,`,
		`OpenNsfwScore:` + fmt.Sprintf("%v", this.OpenNsfwScore) + `,`,
		`ZstdCompressedFingerprint:` + fmt.Sprintf("%v", this.ZstdCompressedFingerprint) + `,`,
		`AlternativeNsfwScore:` + strings.Replace(fmt.Sprintf("%v", this.AlternativeNsfwScore), "ProbeImageReply_AlternativeNSFWScore", "ProbeImageReply_AlternativeNSFWScore", 1) + `,`,
		`ImageHashes:` + strings.Replace(fmt.Sprintf("%v", this.ImageHashes), "ProbeImageReply_ImageHashes", "ProbeImageReply_ImageHashes", 1) + `,`,
		`PerceptualHashOverlapCount:` + fmt.Sprintf("%v", this.PerceptualHashOverlapCount) + `,`,
		`NumberOfFingerprintsRequiringFurtherTesting_1:` + fmt.Sprintf("%v", this.NumberOfFingerprintsRequiringFurtherTesting_1) + `,`,
		`NumberOfFingerprintsRequiringFurtherTesting_2:` + fmt.Sprintf("%v", this.NumberOfFingerprintsRequiringFurtherTesting_2) + `,`,
		`NumberOfFingerprintsRequiringFurtherTesting_3:` + fmt.Sprintf("%v", this.NumberOfFingerprintsRequiringFurtherTesting_3) + `,`,
		`NumberOfFingerprintsRequiringFurtherTesting_4:` + fmt.Sprintf("%v", this.NumberOfFingerprintsRequiringFurtherTesting_4) + `,`,
		`NumberOfFingerprintsRequiringFurtherTesting_5:` + fmt.Sprintf("%v", this.NumberOfFingerprintsRequiringFurtherTesting_5) + `,`,
		`NumberOfFingerprintsRequiringFurtherTesting_6:` + fmt.Sprintf("%v", this.NumberOfFingerprintsRequiringFurtherTesting_6) + `,`,
		`NumberOfFingerprintsOfSuspectedDupes:` + fmt.Sprintf("%v", this.NumberOfFingerprintsOfSuspectedDupes) + `,`,
		`PearsonMax:` + fmt.Sprintf("%v", this.PearsonMax) + `,`,
		`SpearmanMax:` + fmt.Sprintf("%v", this.SpearmanMax) + `,`,
		`KendallMax:` + fmt.Sprintf("%v", this.KendallMax) + `,`,
		`HoeffdingMax:` + fmt.Sprintf("%v", this.HoeffdingMax) + `,`,
		`MutualInformationMax:` + fmt.Sprintf("%v", this.MutualInformationMax) + `,`,
		`HsicMax:` + fmt.Sprintf("%v", this.HsicMax) + `,`,
		`XgbimportanceMax:` + fmt.Sprintf("%v", this.XgbimportanceMax) + `,`,
		`PearsonTop_1BpsPercentile:` + fmt.Sprintf("%v", this.PearsonTop_1BpsPercentile) + `,`,
		`SpearmanTop_1BpsPercentile:` + fmt.Sprintf("%v", this.SpearmanTop_1BpsPercentile) + `,`,
		`KendallTop_1BpsPercentile:` + fmt.Sprintf("%v", this.KendallTop_1BpsPercentile) + `,`,
		`HoeffdingTop_10BpsPercentile:` + fmt.Sprintf("%v", this.HoeffdingTop_10BpsPercentile) + `,`,
		`MutualInformationTop_100BpsPercentile:` + fmt.Sprintf("%v", this.MutualInformationTop_100BpsPercentile) + `,`,
		`HsicTop_100BpsPercentile:` + fmt.Sprintf("%v", this.HsicTop_100BpsPercentile) + `,`,
		`XgbimportanceTop_100BpsPercentile:` + fmt.Sprintf("%v", this.XgbimportanceTop_100BpsPercentile) + `,`,
		`CombinedRarenessScore:` + fmt.Sprintf("%v", this.CombinedRarenessScore) + `,`,
		`XgboostPredictedRarenessScore:` + fmt.Sprintf("%v", this.XgboostPredictedRarenessScore) + `,`,
		`NnPredictedRarenessScore:` + fmt.Sprintf("%v", this.NnPredictedRarenessScore) + `,`,
		`OverallAverageRarenessScore:` + fmt.Sprintf("%v", this.OverallAverageRarenessScore) + `,`,
		`IsLikelyDupe:` + fmt.Sprintf("%v", this.IsLikelyDupe) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeImageReply_AlternativeNSFWScore) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeImageReply_AlternativeNSFWScore{`,
		`Drawing:` + fmt.Sprintf("%v", this.Drawing) + `,`,
		`Hentai:` + fmt.Sprintf("%v", this.Hentai) + `,`,
		`Neutral:` + fmt.Sprintf("%v", this.Neutral) + `,`,
		`Porn:` + fmt.Sprintf("%v", this.Porn) + `,`,
		`Sexy:` + fmt.Sprintf("%v", this.Sexy) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ProbeImageReply_ImageHashes) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ProbeImageReply_ImageHashes{`,
		`PerceptualHash:` + fmt.Sprintf("%v", this.PerceptualHash) + `,`,
		`AverageHash:` + fmt.Sprintf("%v", this.AverageHash) + `,`,
		`DifferenceHash:` + fmt.Sprintf("%v", this.DifferenceHash) + `,`,
		`PDQHash:` + fmt.Sprintf("%v", this.PDQHash) + `,`,
		`NeuralHash:` + fmt.Sprintf("%v", this.NeuralHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EncoderParameters) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EncoderParameters{`,
		`Oti:` + fmt.Sprintf("%v", this.Oti) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendSignedNFTTicketRequest) String() string {
	if this == nil {
		return "nil"
	}
	keysForEncodeFiles := make([]string, 0, len(this.EncodeFiles))
	for k, _ := range this.EncodeFiles {
		keysForEncodeFiles = append(keysForEncodeFiles, k)
	}
	github_com_gogo_protobuf_sortkeys.Strings(keysForEncodeFiles)
	mapStringForEncodeFiles := "map[string][]byte{"
	for _, k := range keysForEncodeFiles {
		mapStringForEncodeFiles += fmt.Sprintf("%v: %v,", k, this.EncodeFiles[k])
	}
	mapStringForEncodeFiles += "}"
	s := strings.Join([]string{`&SendSignedNFTTicketRequest{`,
		`NftTicket:` + fmt.Sprintf("%v", this.NftTicket) + `,`,
		`CreatorSignature:` + fmt.Sprintf("%v", this.CreatorSignature) + `,`,
		`Key1:` + fmt.Sprintf("%v", this.Key1) + `,`,
		`Key2:` + fmt.Sprintf("%v", this.Key2) + `,`,
		`EncodeParameters:` + strings.Replace(this.EncodeParameters.String(), "EncoderParameters", "EncoderParameters", 1) + `,`,
		`EncodeFiles:` + mapStringForEncodeFiles + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendSignedNFTTicketReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendSignedNFTTicketReply{`,
		`RegistrationFee:` + fmt.Sprintf("%v", this.RegistrationFee) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPreBurntFeeTxidRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPreBurntFeeTxidRequest{`,
		`Txid:` + fmt.Sprintf("%v", this.Txid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendPreBurntFeeTxidReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendPreBurntFeeTxidReply{`,
		`NFTRegTxid:` + fmt.Sprintf("%v", this.NFTRegTxid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendTicketRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendTicketRequest{`,
		`Ticket:` + fmt.Sprintf("%v", this.Ticket) + `,`,
		`TicketSignature:` + fmt.Sprintf("%v", this.TicketSignature) + `,`,
		`Fgpt:` + fmt.Sprintf("%v", this.Fgpt) + `,`,
		`FgptSignature:` + fmt.Sprintf("%v", this.FgptSignature) + `,`,
		`FeeTxid:` + fmt.Sprintf("%v", this.FeeTxid) + `,`,
		`Thumbnail:` + fmt.Sprintf("%v", this.Thumbnail) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendTicketReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendTicketReply{`,
		`TicketTxid:` + fmt.Sprintf("%v", this.TicketTxid) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadImageRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadImageRequest{`,
		`Payload:` + fmt.Sprintf("%v", this.Payload) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadImageRequest_ImagePiece) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadImageRequest_ImagePiece{`,
		`ImagePiece:` + fmt.Sprintf("%v", this.ImagePiece) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadImageRequest_MetaData_) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadImageRequest_MetaData_{`,
		`MetaData:` + strings.Replace(fmt.Sprintf("%v", this.MetaData), "UploadImageRequest_MetaData", "UploadImageRequest_MetaData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadImageRequest_Coordinate) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadImageRequest_Coordinate{`,
		`TopLeftX:` + fmt.Sprintf("%v", this.TopLeftX) + `,`,
		`TopLeftY:` + fmt.Sprintf("%v", this.TopLeftY) + `,`,
		`BottomRightX:` + fmt.Sprintf("%v", this.BottomRightX) + `,`,
		`BottomRightY:` + fmt.Sprintf("%v", this.BottomRightY) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadImageRequest_MetaData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadImageRequest_MetaData{`,
		`Size_:` + fmt.Sprintf("%v", this.Size_) + `,`,
		`Format:` + fmt.Sprintf("%v", this.Format) + `,`,
		`Hash:` + fmt.Sprintf("%v", this.Hash) + `,`,
		`Thumbnail:` + strings.Replace(fmt.Sprintf("%v", this.Thumbnail), "UploadImageRequest_Coordinate", "UploadImageRequest_Coordinate", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UploadImageReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UploadImageReply{`,
		`PreviewThumbnailHash:` + fmt.Sprintf("%v", this.PreviewThumbnailHash) + `,`,
		`MediumThumbnailHash:` + fmt.Sprintf("%v", this.MediumThumbnailHash) + `,`,
		`SmallThumbnailHash:` + fmt.Sprintf("%v", this.SmallThumbnailHash) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringRegisterArtwork(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SessionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptedNodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptedNodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptedNodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptedNodesReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptedNodesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptedNodesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &AcceptedNodesReply_Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptedNodesReply_Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectToRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectToRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectToRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectToReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectToReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectToReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeImageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProbeImageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProbeImageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DupeDetectionVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DupeDetectionVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashOfCandidateImg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HashOfCandidateImg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageRarenessScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AverageRarenessScore = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRareOnInternet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRareOnInternet = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchesFoundOnFirstPage", wireType)
			}
			m.MatchesFoundOnFirstPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchesFoundOnFirstPage |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfPagesOfResults", wireType)
			}
			m.NumberOfPagesOfResults = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfPagesOfResults |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlOfFirstMatchInPage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UrlOfFirstMatchInPage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenNsfwScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OpenNsfwScore = float32(math.Float32frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZstdCompressedFingerprint", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZstdCompressedFingerprint = append(m.ZstdCompressedFingerprint[:0], dAtA[iNdEx:postIndex]...)
			if m.ZstdCompressedFingerprint == nil {
				m.ZstdCompressedFingerprint = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternativeNsfwScore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AlternativeNsfwScore == nil {
				m.AlternativeNsfwScore = &ProbeImageReply_AlternativeNSFWScore{}
			}
			if err := m.AlternativeNsfwScore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ImageHashes == nil {
				m.ImageHashes = &ProbeImageReply_ImageHashes{}
			}
			if err := m.ImageHashes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerceptualHashOverlapCount", wireType)
			}
			m.PerceptualHashOverlapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerceptualHashOverlapCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsRequiringFurtherTesting_1", wireType)
			}
			m.NumberOfFingerprintsRequiringFurtherTesting_1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsRequiringFurtherTesting_1 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsRequiringFurtherTesting_2", wireType)
			}
			m.NumberOfFingerprintsRequiringFurtherTesting_2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsRequiringFurtherTesting_2 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsRequiringFurtherTesting_3", wireType)
			}
			m.NumberOfFingerprintsRequiringFurtherTesting_3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsRequiringFurtherTesting_3 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsRequiringFurtherTesting_4", wireType)
			}
			m.NumberOfFingerprintsRequiringFurtherTesting_4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsRequiringFurtherTesting_4 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsRequiringFurtherTesting_5", wireType)
			}
			m.NumberOfFingerprintsRequiringFurtherTesting_5 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsRequiringFurtherTesting_5 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsRequiringFurtherTesting_6", wireType)
			}
			m.NumberOfFingerprintsRequiringFurtherTesting_6 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsRequiringFurtherTesting_6 |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfFingerprintsOfSuspectedDupes", wireType)
			}
			m.NumberOfFingerprintsOfSuspectedDupes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfFingerprintsOfSuspectedDupes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PearsonMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PearsonMax = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpearmanMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SpearmanMax = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KendallMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.KendallMax = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoeffdingMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HoeffdingMax = float32(math.Float32frombits(v))
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutualInformationMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MutualInformationMax = float32(math.Float32frombits(v))
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HsicMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HsicMax = float32(math.Float32frombits(v))
		case 26:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field XgbimportanceMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.XgbimportanceMax = float32(math.Float32frombits(v))
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PearsonTop_1BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PearsonTop_1BpsPercentile = float32(math.Float32frombits(v))
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpearmanTop_1BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SpearmanTop_1BpsPercentile = float32(math.Float32frombits(v))
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field KendallTop_1BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.KendallTop_1BpsPercentile = float32(math.Float32frombits(v))
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoeffdingTop_10BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HoeffdingTop_10BpsPercentile = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MutualInformationTop_100BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MutualInformationTop_100BpsPercentile = float32(math.Float32frombits(v))
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HsicTop_100BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HsicTop_100BpsPercentile = float32(math.Float32frombits(v))
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field XgbimportanceTop_100BpsPercentile", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.XgbimportanceTop_100BpsPercentile = float32(math.Float32frombits(v))
		case 34:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombinedRarenessScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CombinedRarenessScore = float32(math.Float32frombits(v))
		case 35:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field XgboostPredictedRarenessScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.XgboostPredictedRarenessScore = float32(math.Float32frombits(v))
		case 36:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NnPredictedRarenessScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.NnPredictedRarenessScore = float32(math.Float32frombits(v))
		case 37:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallAverageRarenessScore", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OverallAverageRarenessScore = float32(math.Float32frombits(v))
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLikelyDupe", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLikelyDupe = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeImageReply_AlternativeNSFWScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlternativeNSFWScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlternativeNSFWScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drawing", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Drawing = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hentai", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Hentai = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Neutral", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Neutral = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Porn", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Porn = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sexy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Sexy = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProbeImageReply_ImageHashes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageHashes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageHashes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerceptualHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PerceptualHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AverageHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AverageHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DifferenceHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DifferenceHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDQHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PDQHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeuralHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NeuralHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncoderParameters) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncoderParameters: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncoderParameters: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Oti", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Oti = append(m.Oti[:0], dAtA[iNdEx:postIndex]...)
			if m.Oti == nil {
				m.Oti = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSignedNFTTicketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSignedNFTTicketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSignedNFTTicketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NftTicket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NftTicket = append(m.NftTicket[:0], dAtA[iNdEx:postIndex]...)
			if m.NftTicket == nil {
				m.NftTicket = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatorSignature = append(m.CreatorSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.CreatorSignature == nil {
				m.CreatorSignature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodeParameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncodeParameters == nil {
				m.EncodeParameters = &EncoderParameters{}
			}
			if err := m.EncodeParameters.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodeFiles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncodeFiles == nil {
				m.EncodeFiles = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRegisterArtwork
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegisterArtwork
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRegisterArtwork
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRegisterArtwork
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRegisterArtwork
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthRegisterArtwork
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthRegisterArtwork
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRegisterArtwork
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.EncodeFiles[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSignedNFTTicketReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSignedNFTTicketReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSignedNFTTicketReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationFee", wireType)
			}
			m.RegistrationFee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegistrationFee |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPreBurntFeeTxidRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPreBurntFeeTxidRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPreBurntFeeTxidRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPreBurntFeeTxidReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPreBurntFeeTxidReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPreBurntFeeTxidReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NFTRegTxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NFTRegTxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTicketRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTicketRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTicketRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket[:0], dAtA[iNdEx:postIndex]...)
			if m.Ticket == nil {
				m.Ticket = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fgpt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fgpt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FgptSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FgptSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeTxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeTxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendTicketReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendTicketReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendTicketReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TicketTxid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TicketTxid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePiece", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Payload = &UploadImageRequest_ImagePiece{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UploadImageRequest_MetaData{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &UploadImageRequest_MetaData_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadImageRequest_Coordinate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopLeftX", wireType)
			}
			m.TopLeftX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopLeftX |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopLeftY", wireType)
			}
			m.TopLeftY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopLeftY |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomRightX", wireType)
			}
			m.BottomRightX = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BottomRightX |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BottomRightY", wireType)
			}
			m.BottomRightY = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BottomRightY |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadImageRequest_MetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &UploadImageRequest_Coordinate{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadImageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadImageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadImageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviewThumbnailHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviewThumbnailHash = append(m.PreviewThumbnailHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreviewThumbnailHash == nil {
				m.PreviewThumbnailHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediumThumbnailHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediumThumbnailHash = append(m.MediumThumbnailHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MediumThumbnailHash == nil {
				m.MediumThumbnailHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallThumbnailHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SmallThumbnailHash = append(m.SmallThumbnailHash[:0], dAtA[iNdEx:postIndex]...)
			if m.SmallThumbnailHash == nil {
				m.SmallThumbnailHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRegisterArtwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRegisterArtwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRegisterArtwork(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRegisterArtwork
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRegisterArtwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRegisterArtwork
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRegisterArtwork
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRegisterArtwork
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRegisterArtwork        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRegisterArtwork          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRegisterArtwork = fmt.Errorf("proto: unexpected end of group")
)

// Code generated by goa v3.12.4, DO NOT EDIT.
//
// nft HTTP client types
//
// Command:
// $ goa gen github.com/pastelnetwork/gonode/walletnode/api/design

package client

import (
	"unicode/utf8"

	nft "github.com/pastelnetwork/gonode/walletnode/api/gen/nft"
	nftviews "github.com/pastelnetwork/gonode/walletnode/api/gen/nft/views"
	goa "goa.design/goa/v3/pkg"
)

// RegisterRequestBody is the type of the "nft" service "register" endpoint
// HTTP request body.
type RegisterRequestBody struct {
	// Uploaded image ID
	ImageID string `form:"image_id" json:"image_id" xml:"image_id"`
	// Name of the NFT
	Name string `form:"name" json:"name" xml:"name"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Creator's PastelID
	CreatorPastelID string `form:"creator_pastelid" json:"creator_pastelid" xml:"creator_pastelid"`
	// Name of the NFT creator
	CreatorName string `form:"creator_name" json:"creator_name" xml:"creator_name"`
	// NFT creator website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// Spendable address
	SpendableAddress string `form:"spendable_address" json:"spendable_address" xml:"spendable_address"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee float64 `form:"maximum_fee" json:"maximum_fee" xml:"maximum_fee"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                           `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateRequestBody `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
	// To make it publicly accessible
	MakePubliclyAccessible bool `form:"make_publicly_accessible" json:"make_publicly_accessible" xml:"make_publicly_accessible"`
	// Act Collection TxID to add given ticket in collection
	CollectionActTxid *string `form:"collection_act_txid,omitempty" json:"collection_act_txid,omitempty" xml:"collection_act_txid,omitempty"`
	// OpenAPI GroupID string
	OpenAPIGroupID string `form:"open_api_group_id" json:"open_api_group_id" xml:"open_api_group_id"`
}

// UploadImageRequestBody is the type of the "nft" service "uploadImage"
// endpoint HTTP request body.
type UploadImageRequestBody struct {
	// File to upload
	Bytes []byte `form:"file" json:"file" xml:"file"`
	// For internal use
	Filename *string `form:"filename,omitempty" json:"filename,omitempty" xml:"filename,omitempty"`
}

// RegisterResponseBody is the type of the "nft" service "register" endpoint
// HTTP response body.
type RegisterResponseBody struct {
	// Task ID of the registration process
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
}

// RegisterTaskStateResponseBody is the type of the "nft" service
// "registerTaskState" endpoint HTTP response body.
type RegisterTaskStateResponseBody struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// GetTaskHistoryResponseBody is the type of the "nft" service "getTaskHistory"
// endpoint HTTP response body.
type GetTaskHistoryResponseBody []*TaskHistoryResponse

// RegisterTaskResponseBody is the type of the "nft" service "registerTask"
// endpoint HTTP response body.
type RegisterTaskResponseBody struct {
	// JOb ID of the registration process
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of states from the very beginning of the process
	States []*TaskStateResponseBody `form:"states,omitempty" json:"states,omitempty" xml:"states,omitempty"`
	// txid
	Txid   *string                         `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	Ticket *NftRegisterPayloadResponseBody `form:"ticket,omitempty" json:"ticket,omitempty" xml:"ticket,omitempty"`
}

// RegisterTasksResponseBody is the type of the "nft" service "registerTasks"
// endpoint HTTP response body.
type RegisterTasksResponseBody []*TaskResponse

// UploadImageResponseBody is the type of the "nft" service "uploadImage"
// endpoint HTTP response body.
type UploadImageResponseBody struct {
	// Uploaded image ID
	ImageID *string `form:"image_id,omitempty" json:"image_id,omitempty" xml:"image_id,omitempty"`
	// Image expiration
	ExpiresIn *string `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
	// Estimated fee
	EstimatedFee *float64 `form:"estimated_fee,omitempty" json:"estimated_fee,omitempty" xml:"estimated_fee,omitempty"`
}

// NftSearchResponseBody is the type of the "nft" service "nftSearch" endpoint
// HTTP response body.
type NftSearchResponseBody struct {
	// NFT data
	Nft *NftSummaryResponseBody `form:"nft,omitempty" json:"nft,omitempty" xml:"nft,omitempty"`
	// Sort index of the match based on score.This must be used to sort results on
	// UI.
	MatchIndex *int `form:"match_index,omitempty" json:"match_index,omitempty" xml:"match_index,omitempty"`
	// Match result details
	Matches []*FuzzyMatchResponseBody `form:"matches,omitempty" json:"matches,omitempty" xml:"matches,omitempty"`
}

// NftGetResponseBody is the type of the "nft" service "nftGet" endpoint HTTP
// response body.
type NftGetResponseBody struct {
	// version
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// Green address
	GreenAddress *bool `form:"green_address,omitempty" json:"green_address,omitempty" xml:"green_address,omitempty"`
	// how much artist should get on all future resales
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// Storage fee %
	StorageFee *int `form:"storage_fee,omitempty" json:"storage_fee,omitempty" xml:"storage_fee,omitempty"`
	// NSFW Average score
	NsfwScore *float32 `form:"nsfw_score,omitempty" json:"nsfw_score,omitempty" xml:"nsfw_score,omitempty"`
	// Average pastel rareness score
	RarenessScore *float32 `form:"rareness_score,omitempty" json:"rareness_score,omitempty" xml:"rareness_score,omitempty"`
	// Is this image likely a duplicate of another known image
	IsLikelyDupe *bool `form:"is_likely_dupe,omitempty" json:"is_likely_dupe,omitempty" xml:"is_likely_dupe,omitempty"`
	// is this nft rare on the internet
	IsRareOnInternet *bool `form:"is_rare_on_internet,omitempty" json:"is_rare_on_internet,omitempty" xml:"is_rare_on_internet,omitempty"`
	// nsfw score
	DrawingNsfwScore *float32 `form:"drawing_nsfw_score,omitempty" json:"drawing_nsfw_score,omitempty" xml:"drawing_nsfw_score,omitempty"`
	// nsfw score
	NeutralNsfwScore *float32 `form:"neutral_nsfw_score,omitempty" json:"neutral_nsfw_score,omitempty" xml:"neutral_nsfw_score,omitempty"`
	// nsfw score
	SexyNsfwScore *float32 `form:"sexy_nsfw_score,omitempty" json:"sexy_nsfw_score,omitempty" xml:"sexy_nsfw_score,omitempty"`
	// nsfw score
	PornNsfwScore *float32 `form:"porn_nsfw_score,omitempty" json:"porn_nsfw_score,omitempty" xml:"porn_nsfw_score,omitempty"`
	// nsfw score
	HentaiNsfwScore *float32 `form:"hentai_nsfw_score,omitempty" json:"hentai_nsfw_score,omitempty" xml:"hentai_nsfw_score,omitempty"`
	// Preview Image
	PreviewThumbnail []byte `form:"preview_thumbnail,omitempty" json:"preview_thumbnail,omitempty" xml:"preview_thumbnail,omitempty"`
	// Base64 Compressed JSON Table of Rare On Internet Summary
	RareOnInternetSummaryTableJSONB64 *string `form:"rare_on_internet_summary_table_json_b64,omitempty" json:"rare_on_internet_summary_table_json_b64,omitempty" xml:"rare_on_internet_summary_table_json_b64,omitempty"`
	// Base64 Compressed JSON of Rare On Internet Graph
	RareOnInternetGraphJSONB64 *string `form:"rare_on_internet_graph_json_b64,omitempty" json:"rare_on_internet_graph_json_b64,omitempty" xml:"rare_on_internet_graph_json_b64,omitempty"`
	// Base64 Compressed Json of Alternative Rare On Internet Dict
	AltRareOnInternetDictJSONB64 *string `form:"alt_rare_on_internet_dict_json_b64,omitempty" json:"alt_rare_on_internet_dict_json_b64,omitempty" xml:"alt_rare_on_internet_dict_json_b64,omitempty"`
	// Minimum Number of Exact Matches on Page
	MinNumExactMatchesOnPage *uint32 `form:"min_num_exact_matches_on_page,omitempty" json:"min_num_exact_matches_on_page,omitempty" xml:"min_num_exact_matches_on_page,omitempty"`
	// Earliest Available Date of Internet Results
	EarliestDateOfResults *string `form:"earliest_date_of_results,omitempty" json:"earliest_date_of_results,omitempty" xml:"earliest_date_of_results,omitempty"`
	// Thumbnail_1 image
	Thumbnail1 []byte `form:"thumbnail_1,omitempty" json:"thumbnail_1,omitempty" xml:"thumbnail_1,omitempty"`
	// Thumbnail_2 image
	Thumbnail2 []byte `form:"thumbnail_2,omitempty" json:"thumbnail_2,omitempty" xml:"thumbnail_2,omitempty"`
	// txid
	Txid *string `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	// Name of the NFT
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies
	Copies *int `form:"copies,omitempty" json:"copies,omitempty" xml:"copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Name of the artist
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// Artist website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
}

// DownloadResponseBody is the type of the "nft" service "download" endpoint
// HTTP response body.
type DownloadResponseBody struct {
	// File path
	FileID *string `form:"file_id,omitempty" json:"file_id,omitempty" xml:"file_id,omitempty"`
}

// DdServiceOutputFileDetailResponseBody is the type of the "nft" service
// "ddServiceOutputFileDetail" endpoint HTTP response body.
type DdServiceOutputFileDetailResponseBody struct {
	// block hash when request submitted
	PastelBlockHashWhenRequestSubmitted *string `form:"pastel_block_hash_when_request_submitted,omitempty" json:"pastel_block_hash_when_request_submitted,omitempty" xml:"pastel_block_hash_when_request_submitted,omitempty"`
	// block Height when request submitted
	PastelBlockHeightWhenRequestSubmitted *string `form:"pastel_block_height_when_request_submitted,omitempty" json:"pastel_block_height_when_request_submitted,omitempty" xml:"pastel_block_height_when_request_submitted,omitempty"`
	// timestamp of request when submitted
	UtcTimestampWhenRequestSubmitted *string `form:"utc_timestamp_when_request_submitted,omitempty" json:"utc_timestamp_when_request_submitted,omitempty" xml:"utc_timestamp_when_request_submitted,omitempty"`
	// pastel id of the submitter
	PastelIDOfSubmitter *string `form:"pastel_id_of_submitter,omitempty" json:"pastel_id_of_submitter,omitempty" xml:"pastel_id_of_submitter,omitempty"`
	// pastel id of registering SN1
	PastelIDOfRegisteringSupernode1 *string `form:"pastel_id_of_registering_supernode_1,omitempty" json:"pastel_id_of_registering_supernode_1,omitempty" xml:"pastel_id_of_registering_supernode_1,omitempty"`
	// pastel id of registering SN2
	PastelIDOfRegisteringSupernode2 *string `form:"pastel_id_of_registering_supernode_2,omitempty" json:"pastel_id_of_registering_supernode_2,omitempty" xml:"pastel_id_of_registering_supernode_2,omitempty"`
	// pastel id of registering SN3
	PastelIDOfRegisteringSupernode3 *string `form:"pastel_id_of_registering_supernode_3,omitempty" json:"pastel_id_of_registering_supernode_3,omitempty" xml:"pastel_id_of_registering_supernode_3,omitempty"`
	// is pastel open API request
	IsPastelOpenapiRequest *bool `form:"is_pastel_openapi_request,omitempty" json:"is_pastel_openapi_request,omitempty" xml:"is_pastel_openapi_request,omitempty"`
	// system version of dupe detection
	DupeDetectionSystemVersion *string `form:"dupe_detection_system_version,omitempty" json:"dupe_detection_system_version,omitempty" xml:"dupe_detection_system_version,omitempty"`
	// is this nft likely a duplicate
	IsLikelyDupe *bool `form:"is_likely_dupe,omitempty" json:"is_likely_dupe,omitempty" xml:"is_likely_dupe,omitempty"`
	// is this nft rare on the internet
	IsRareOnInternet *bool `form:"is_rare_on_internet,omitempty" json:"is_rare_on_internet,omitempty" xml:"is_rare_on_internet,omitempty"`
	// pastel rareness score
	OverallRarenessScore *float32 `form:"overall_rareness_score,omitempty" json:"overall_rareness_score,omitempty" xml:"overall_rareness_score,omitempty"`
	// PCT of top 10 most similar with dupe probe above 25 PCT
	PctOfTop10MostSimilarWithDupeProbAbove25pct *float32 `form:"pct_of_top_10_most_similar_with_dupe_prob_above_25pct,omitempty" json:"pct_of_top_10_most_similar_with_dupe_prob_above_25pct,omitempty" xml:"pct_of_top_10_most_similar_with_dupe_prob_above_25pct,omitempty"`
	// PCT of top 10 most similar with dupe probe above 33 PCT
	PctOfTop10MostSimilarWithDupeProbAbove33pct *float32 `form:"pct_of_top_10_most_similar_with_dupe_prob_above_33pct,omitempty" json:"pct_of_top_10_most_similar_with_dupe_prob_above_33pct,omitempty" xml:"pct_of_top_10_most_similar_with_dupe_prob_above_33pct,omitempty"`
	// PCT of top 10 most similar with dupe probe above 50 PCT
	PctOfTop10MostSimilarWithDupeProbAbove50pct *float32 `form:"pct_of_top_10_most_similar_with_dupe_prob_above_50pct,omitempty" json:"pct_of_top_10_most_similar_with_dupe_prob_above_50pct,omitempty" xml:"pct_of_top_10_most_similar_with_dupe_prob_above_50pct,omitempty"`
	// rareness scores table json compressed b64
	RarenessScoresTableJSONCompressedB64 *string `form:"rareness_scores_table_json_compressed_b64,omitempty" json:"rareness_scores_table_json_compressed_b64,omitempty" xml:"rareness_scores_table_json_compressed_b64,omitempty"`
	// open nsfw score
	OpenNsfwScore *float32 `form:"open_nsfw_score,omitempty" json:"open_nsfw_score,omitempty" xml:"open_nsfw_score,omitempty"`
	// Image fingerprint of candidate image file
	ImageFingerprintOfCandidateImageFile []float64 `form:"image_fingerprint_of_candidate_image_file,omitempty" json:"image_fingerprint_of_candidate_image_file,omitempty" xml:"image_fingerprint_of_candidate_image_file,omitempty"`
	// hash of candidate image file
	HashOfCandidateImageFile *string `form:"hash_of_candidate_image_file,omitempty" json:"hash_of_candidate_image_file,omitempty" xml:"hash_of_candidate_image_file,omitempty"`
	// name of the collection
	CollectionNameString *string `form:"collection_name_string,omitempty" json:"collection_name_string,omitempty" xml:"collection_name_string,omitempty"`
	// open api group id string
	OpenAPIGroupIDString *string `form:"open_api_group_id_string,omitempty" json:"open_api_group_id_string,omitempty" xml:"open_api_group_id_string,omitempty"`
	// rareness score of the group
	GroupRarenessScore *float32 `form:"group_rareness_score,omitempty" json:"group_rareness_score,omitempty" xml:"group_rareness_score,omitempty"`
	// candidate image thumbnail as base64 string
	CandidateImageThumbnailWebpAsBase64String *string `form:"candidate_image_thumbnail_webp_as_base64_string,omitempty" json:"candidate_image_thumbnail_webp_as_base64_string,omitempty" xml:"candidate_image_thumbnail_webp_as_base64_string,omitempty"`
	// does not impact collection strings
	DoesNotImpactTheFollowingCollectionStrings *string `form:"does_not_impact_the_following_collection_strings,omitempty" json:"does_not_impact_the_following_collection_strings,omitempty" xml:"does_not_impact_the_following_collection_strings,omitempty"`
	// similarity score to first entry in collection
	SimilarityScoreToFirstEntryInCollection *float32 `form:"similarity_score_to_first_entry_in_collection,omitempty" json:"similarity_score_to_first_entry_in_collection,omitempty" xml:"similarity_score_to_first_entry_in_collection,omitempty"`
	// probability of CP
	CpProbability *float32 `form:"cp_probability,omitempty" json:"cp_probability,omitempty" xml:"cp_probability,omitempty"`
	// child probability
	ChildProbability *float32 `form:"child_probability,omitempty" json:"child_probability,omitempty" xml:"child_probability,omitempty"`
	// file path of the image
	ImageFilePath *string `form:"image_file_path,omitempty" json:"image_file_path,omitempty" xml:"image_file_path,omitempty"`
	// internet rareness
	InternetRareness *InternetRarenessResponseBody `form:"internet_rareness,omitempty" json:"internet_rareness,omitempty" xml:"internet_rareness,omitempty"`
	// alternative NSFW scores
	AlternativeNsfwScores *AlternativeNSFWScoresResponseBody `form:"alternative_nsfw_scores,omitempty" json:"alternative_nsfw_scores,omitempty" xml:"alternative_nsfw_scores,omitempty"`
	// name of the creator
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// website of creator
	CreatorWebsite *string `form:"creator_website,omitempty" json:"creator_website,omitempty" xml:"creator_website,omitempty"`
	// written statement of creator
	CreatorWrittenStatement *string `form:"creator_written_statement,omitempty" json:"creator_written_statement,omitempty" xml:"creator_written_statement,omitempty"`
	// title of NFT
	NftTitle *string `form:"nft_title,omitempty" json:"nft_title,omitempty" xml:"nft_title,omitempty"`
	// series name of NFT
	NftSeriesName *string `form:"nft_series_name,omitempty" json:"nft_series_name,omitempty" xml:"nft_series_name,omitempty"`
	// nft creation video youtube url
	NftCreationVideoYoutubeURL *string `form:"nft_creation_video_youtube_url,omitempty" json:"nft_creation_video_youtube_url,omitempty" xml:"nft_creation_video_youtube_url,omitempty"`
	// keywords for NFT
	NftKeywordSet *string `form:"nft_keyword_set,omitempty" json:"nft_keyword_set,omitempty" xml:"nft_keyword_set,omitempty"`
	// total copies of NFT
	TotalCopies *int `form:"total_copies,omitempty" json:"total_copies,omitempty" xml:"total_copies,omitempty"`
	// preview hash of NFT
	PreviewHash []byte `form:"preview_hash,omitempty" json:"preview_hash,omitempty" xml:"preview_hash,omitempty"`
	// thumbnail1 hash of NFT
	Thumbnail1Hash []byte `form:"thumbnail1_hash,omitempty" json:"thumbnail1_hash,omitempty" xml:"thumbnail1_hash,omitempty"`
	// thumbnail2 hash of NFT
	Thumbnail2Hash []byte `form:"thumbnail2_hash,omitempty" json:"thumbnail2_hash,omitempty" xml:"thumbnail2_hash,omitempty"`
	// original file size in bytes
	OriginalFileSizeInBytes *int `form:"original_file_size_in_bytes,omitempty" json:"original_file_size_in_bytes,omitempty" xml:"original_file_size_in_bytes,omitempty"`
	// type of the file
	FileType *string `form:"file_type,omitempty" json:"file_type,omitempty" xml:"file_type,omitempty"`
	// max permitted open NSFW score
	MaxPermittedOpenNsfwScore *float64 `form:"max_permitted_open_nsfw_score,omitempty" json:"max_permitted_open_nsfw_score,omitempty" xml:"max_permitted_open_nsfw_score,omitempty"`
}

// DdServiceOutputFileResponseBody is the type of the "nft" service
// "ddServiceOutputFile" endpoint HTTP response body.
type DdServiceOutputFileResponseBody struct {
	// File downloaded
	File *string `form:"file,omitempty" json:"file,omitempty" xml:"file,omitempty"`
}

// RegisterBadRequestResponseBody is the type of the "nft" service "register"
// endpoint HTTP response body for the "BadRequest" error.
type RegisterBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterInternalServerErrorResponseBody is the type of the "nft" service
// "register" endpoint HTTP response body for the "InternalServerError" error.
type RegisterInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskStateNotFoundResponseBody is the type of the "nft" service
// "registerTaskState" endpoint HTTP response body for the "NotFound" error.
type RegisterTaskStateNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskStateInternalServerErrorResponseBody is the type of the "nft"
// service "registerTaskState" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTaskStateInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetTaskHistoryNotFoundResponseBody is the type of the "nft" service
// "getTaskHistory" endpoint HTTP response body for the "NotFound" error.
type GetTaskHistoryNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// GetTaskHistoryInternalServerErrorResponseBody is the type of the "nft"
// service "getTaskHistory" endpoint HTTP response body for the
// "InternalServerError" error.
type GetTaskHistoryInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskNotFoundResponseBody is the type of the "nft" service
// "registerTask" endpoint HTTP response body for the "NotFound" error.
type RegisterTaskNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskInternalServerErrorResponseBody is the type of the "nft" service
// "registerTask" endpoint HTTP response body for the "InternalServerError"
// error.
type RegisterTaskInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTasksInternalServerErrorResponseBody is the type of the "nft"
// service "registerTasks" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTasksInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UploadImageBadRequestResponseBody is the type of the "nft" service
// "uploadImage" endpoint HTTP response body for the "BadRequest" error.
type UploadImageBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UploadImageInternalServerErrorResponseBody is the type of the "nft" service
// "uploadImage" endpoint HTTP response body for the "InternalServerError"
// error.
type UploadImageInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftSearchBadRequestResponseBody is the type of the "nft" service "nftSearch"
// endpoint HTTP response body for the "BadRequest" error.
type NftSearchBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftSearchInternalServerErrorResponseBody is the type of the "nft" service
// "nftSearch" endpoint HTTP response body for the "InternalServerError" error.
type NftSearchInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftGetBadRequestResponseBody is the type of the "nft" service "nftGet"
// endpoint HTTP response body for the "BadRequest" error.
type NftGetBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftGetNotFoundResponseBody is the type of the "nft" service "nftGet"
// endpoint HTTP response body for the "NotFound" error.
type NftGetNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftGetInternalServerErrorResponseBody is the type of the "nft" service
// "nftGet" endpoint HTTP response body for the "InternalServerError" error.
type NftGetInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DownloadNotFoundResponseBody is the type of the "nft" service "download"
// endpoint HTTP response body for the "NotFound" error.
type DownloadNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DownloadInternalServerErrorResponseBody is the type of the "nft" service
// "download" endpoint HTTP response body for the "InternalServerError" error.
type DownloadInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DdServiceOutputFileDetailNotFoundResponseBody is the type of the "nft"
// service "ddServiceOutputFileDetail" endpoint HTTP response body for the
// "NotFound" error.
type DdServiceOutputFileDetailNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DdServiceOutputFileDetailInternalServerErrorResponseBody is the type of the
// "nft" service "ddServiceOutputFileDetail" endpoint HTTP response body for
// the "InternalServerError" error.
type DdServiceOutputFileDetailInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DdServiceOutputFileNotFoundResponseBody is the type of the "nft" service
// "ddServiceOutputFile" endpoint HTTP response body for the "NotFound" error.
type DdServiceOutputFileNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DdServiceOutputFileInternalServerErrorResponseBody is the type of the "nft"
// service "ddServiceOutputFile" endpoint HTTP response body for the
// "InternalServerError" error.
type DdServiceOutputFileInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ThumbnailcoordinateRequestBody is used to define fields on request body
// types.
type ThumbnailcoordinateRequestBody struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX int64 `form:"top_left_x" json:"top_left_x" xml:"top_left_x"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY int64 `form:"top_left_y" json:"top_left_y" xml:"top_left_y"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX int64 `form:"bottom_right_x" json:"bottom_right_x" xml:"bottom_right_x"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY int64 `form:"bottom_right_y" json:"bottom_right_y" xml:"bottom_right_y"`
}

// TaskHistoryResponse is used to define fields on response body types.
type TaskHistoryResponse struct {
	// Timestamp of the status creation
	Timestamp *string `form:"timestamp,omitempty" json:"timestamp,omitempty" xml:"timestamp,omitempty"`
	// past status string
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// message string (if any)
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// details of the status
	Details *DetailsResponse `form:"details,omitempty" json:"details,omitempty" xml:"details,omitempty"`
}

// DetailsResponse is used to define fields on response body types.
type DetailsResponse struct {
	// details regarding the status
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// important fields regarding status history
	Fields map[string]any `form:"fields,omitempty" json:"fields,omitempty" xml:"fields,omitempty"`
}

// TaskStateResponseBody is used to define fields on response body types.
type TaskStateResponseBody struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// NftRegisterPayloadResponseBody is used to define fields on response body
// types.
type NftRegisterPayloadResponseBody struct {
	// Name of the NFT
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Creator's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Name of the NFT creator
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// NFT creator website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// Spendable address
	SpendableAddress *string `form:"spendable_address,omitempty" json:"spendable_address,omitempty" xml:"spendable_address,omitempty"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee *float64 `form:"maximum_fee,omitempty" json:"maximum_fee,omitempty" xml:"maximum_fee,omitempty"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                            `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateResponseBody `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
	// To make it publicly accessible
	MakePubliclyAccessible *bool `form:"make_publicly_accessible,omitempty" json:"make_publicly_accessible,omitempty" xml:"make_publicly_accessible,omitempty"`
	// Act Collection TxID to add given ticket in collection
	CollectionActTxid *string `form:"collection_act_txid,omitempty" json:"collection_act_txid,omitempty" xml:"collection_act_txid,omitempty"`
	// OpenAPI GroupID string
	OpenAPIGroupID *string `form:"open_api_group_id,omitempty" json:"open_api_group_id,omitempty" xml:"open_api_group_id,omitempty"`
	// Passphrase of the owner's PastelID
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
}

// ThumbnailcoordinateResponseBody is used to define fields on response body
// types.
type ThumbnailcoordinateResponseBody struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX *int64 `form:"top_left_x,omitempty" json:"top_left_x,omitempty" xml:"top_left_x,omitempty"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY *int64 `form:"top_left_y,omitempty" json:"top_left_y,omitempty" xml:"top_left_y,omitempty"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX *int64 `form:"bottom_right_x,omitempty" json:"bottom_right_x,omitempty" xml:"bottom_right_x,omitempty"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY *int64 `form:"bottom_right_y,omitempty" json:"bottom_right_y,omitempty" xml:"bottom_right_y,omitempty"`
}

// TaskResponse is used to define fields on response body types.
type TaskResponse struct {
	// JOb ID of the registration process
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of states from the very beginning of the process
	States []*TaskStateResponse `form:"states,omitempty" json:"states,omitempty" xml:"states,omitempty"`
	// txid
	Txid   *string                     `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	Ticket *NftRegisterPayloadResponse `form:"ticket,omitempty" json:"ticket,omitempty" xml:"ticket,omitempty"`
}

// TaskStateResponse is used to define fields on response body types.
type TaskStateResponse struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// NftRegisterPayloadResponse is used to define fields on response body types.
type NftRegisterPayloadResponse struct {
	// Name of the NFT
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Creator's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Name of the NFT creator
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// NFT creator website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// Spendable address
	SpendableAddress *string `form:"spendable_address,omitempty" json:"spendable_address,omitempty" xml:"spendable_address,omitempty"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee *float64 `form:"maximum_fee,omitempty" json:"maximum_fee,omitempty" xml:"maximum_fee,omitempty"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                        `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateResponse `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
	// To make it publicly accessible
	MakePubliclyAccessible *bool `form:"make_publicly_accessible,omitempty" json:"make_publicly_accessible,omitempty" xml:"make_publicly_accessible,omitempty"`
	// Act Collection TxID to add given ticket in collection
	CollectionActTxid *string `form:"collection_act_txid,omitempty" json:"collection_act_txid,omitempty" xml:"collection_act_txid,omitempty"`
	// OpenAPI GroupID string
	OpenAPIGroupID *string `form:"open_api_group_id,omitempty" json:"open_api_group_id,omitempty" xml:"open_api_group_id,omitempty"`
	// Passphrase of the owner's PastelID
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
}

// ThumbnailcoordinateResponse is used to define fields on response body types.
type ThumbnailcoordinateResponse struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX *int64 `form:"top_left_x,omitempty" json:"top_left_x,omitempty" xml:"top_left_x,omitempty"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY *int64 `form:"top_left_y,omitempty" json:"top_left_y,omitempty" xml:"top_left_y,omitempty"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX *int64 `form:"bottom_right_x,omitempty" json:"bottom_right_x,omitempty" xml:"bottom_right_x,omitempty"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY *int64 `form:"bottom_right_y,omitempty" json:"bottom_right_y,omitempty" xml:"bottom_right_y,omitempty"`
}

// NftSummaryResponseBody is used to define fields on response body types.
type NftSummaryResponseBody struct {
	// Thumbnail_1 image
	Thumbnail1 []byte `form:"thumbnail_1,omitempty" json:"thumbnail_1,omitempty" xml:"thumbnail_1,omitempty"`
	// Thumbnail_2 image
	Thumbnail2 []byte `form:"thumbnail_2,omitempty" json:"thumbnail_2,omitempty" xml:"thumbnail_2,omitempty"`
	// txid
	Txid *string `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	// Name of the NFT
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies
	Copies *int `form:"copies,omitempty" json:"copies,omitempty" xml:"copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Name of the artist
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// Artist website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// NSFW Average score
	NsfwScore *float32 `form:"nsfw_score,omitempty" json:"nsfw_score,omitempty" xml:"nsfw_score,omitempty"`
	// Average pastel rareness score
	RarenessScore *float32 `form:"rareness_score,omitempty" json:"rareness_score,omitempty" xml:"rareness_score,omitempty"`
	// Is this image likely a duplicate of another known image
	IsLikelyDupe *bool `form:"is_likely_dupe,omitempty" json:"is_likely_dupe,omitempty" xml:"is_likely_dupe,omitempty"`
}

// FuzzyMatchResponseBody is used to define fields on response body types.
type FuzzyMatchResponseBody struct {
	// String that is matched
	Str *string `form:"str,omitempty" json:"str,omitempty" xml:"str,omitempty"`
	// Field that is matched
	FieldType *string `form:"field_type,omitempty" json:"field_type,omitempty" xml:"field_type,omitempty"`
	// The indexes of matched characters. Useful for highlighting matches
	MatchedIndexes []int `form:"matched_indexes,omitempty" json:"matched_indexes,omitempty" xml:"matched_indexes,omitempty"`
	// Score used to rank matches
	Score *int `form:"score,omitempty" json:"score,omitempty" xml:"score,omitempty"`
}

// InternetRarenessResponseBody is used to define fields on response body types.
type InternetRarenessResponseBody struct {
	// Base64 Compressed JSON Table of Rare On Internet Summary
	RareOnInternetSummaryTableAsJSONCompressedB64 *string `form:"rare_on_internet_summary_table_as_json_compressed_b64,omitempty" json:"rare_on_internet_summary_table_as_json_compressed_b64,omitempty" xml:"rare_on_internet_summary_table_as_json_compressed_b64,omitempty"`
	// Base64 Compressed JSON of Rare On Internet Graph
	RareOnInternetGraphJSONCompressedB64 *string `form:"rare_on_internet_graph_json_compressed_b64,omitempty" json:"rare_on_internet_graph_json_compressed_b64,omitempty" xml:"rare_on_internet_graph_json_compressed_b64,omitempty"`
	// Base64 Compressed Json of Alternative Rare On Internet Dict
	AlternativeRareOnInternetDictAsJSONCompressedB64 *string `form:"alternative_rare_on_internet_dict_as_json_compressed_b64,omitempty" json:"alternative_rare_on_internet_dict_as_json_compressed_b64,omitempty" xml:"alternative_rare_on_internet_dict_as_json_compressed_b64,omitempty"`
	// Minimum Number of Exact Matches on Page
	MinNumberOfExactMatchesInPage *uint32 `form:"min_number_of_exact_matches_in_page,omitempty" json:"min_number_of_exact_matches_in_page,omitempty" xml:"min_number_of_exact_matches_in_page,omitempty"`
	// Earliest Available Date of Internet Results
	EarliestAvailableDateOfInternetResults *string `form:"earliest_available_date_of_internet_results,omitempty" json:"earliest_available_date_of_internet_results,omitempty" xml:"earliest_available_date_of_internet_results,omitempty"`
}

// AlternativeNSFWScoresResponseBody is used to define fields on response body
// types.
type AlternativeNSFWScoresResponseBody struct {
	// drawings nsfw score
	Drawings *float32 `form:"drawings,omitempty" json:"drawings,omitempty" xml:"drawings,omitempty"`
	// hentai nsfw score
	Hentai *float32 `form:"hentai,omitempty" json:"hentai,omitempty" xml:"hentai,omitempty"`
	// sexy nsfw score
	Sexy *float32 `form:"sexy,omitempty" json:"sexy,omitempty" xml:"sexy,omitempty"`
	// porn nsfw score
	Porn *float32 `form:"porn,omitempty" json:"porn,omitempty" xml:"porn,omitempty"`
	// neutral nsfw score
	Neutral *float32 `form:"neutral,omitempty" json:"neutral,omitempty" xml:"neutral,omitempty"`
}

// NewRegisterRequestBody builds the HTTP request body from the payload of the
// "register" endpoint of the "nft" service.
func NewRegisterRequestBody(p *nft.RegisterPayload) *RegisterRequestBody {
	body := &RegisterRequestBody{
		ImageID:                p.ImageID,
		Name:                   p.Name,
		Description:            p.Description,
		Keywords:               p.Keywords,
		SeriesName:             p.SeriesName,
		IssuedCopies:           p.IssuedCopies,
		YoutubeURL:             p.YoutubeURL,
		CreatorPastelID:        p.CreatorPastelID,
		CreatorName:            p.CreatorName,
		CreatorWebsiteURL:      p.CreatorWebsiteURL,
		SpendableAddress:       p.SpendableAddress,
		MaximumFee:             p.MaximumFee,
		Royalty:                p.Royalty,
		Green:                  p.Green,
		MakePubliclyAccessible: p.MakePubliclyAccessible,
		CollectionActTxid:      p.CollectionActTxid,
		OpenAPIGroupID:         p.OpenAPIGroupID,
	}
	if p.ThumbnailCoordinate != nil {
		body.ThumbnailCoordinate = marshalNftThumbnailcoordinateToThumbnailcoordinateRequestBody(p.ThumbnailCoordinate)
	}
	{
		var zero bool
		if body.MakePubliclyAccessible == zero {
			body.MakePubliclyAccessible = false
		}
	}
	{
		var zero string
		if body.OpenAPIGroupID == zero {
			body.OpenAPIGroupID = "PASTEL"
		}
	}
	return body
}

// NewUploadImageRequestBody builds the HTTP request body from the payload of
// the "uploadImage" endpoint of the "nft" service.
func NewUploadImageRequestBody(p *nft.UploadImagePayload) *UploadImageRequestBody {
	body := &UploadImageRequestBody{
		Bytes:    p.Bytes,
		Filename: p.Filename,
	}
	return body
}

// NewRegisterResultViewCreated builds a "nft" service "register" endpoint
// result from a HTTP "Created" response.
func NewRegisterResultViewCreated(body *RegisterResponseBody) *nftviews.RegisterResultView {
	v := &nftviews.RegisterResultView{
		TaskID: body.TaskID,
	}

	return v
}

// NewRegisterBadRequest builds a nft service register endpoint BadRequest
// error.
func NewRegisterBadRequest(body *RegisterBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterInternalServerError builds a nft service register endpoint
// InternalServerError error.
func NewRegisterInternalServerError(body *RegisterInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskStateTaskStateOK builds a "nft" service "registerTaskState"
// endpoint result from a HTTP "OK" response.
func NewRegisterTaskStateTaskStateOK(body *RegisterTaskStateResponseBody) *nft.TaskState {
	v := &nft.TaskState{
		Date:   *body.Date,
		Status: *body.Status,
	}

	return v
}

// NewRegisterTaskStateNotFound builds a nft service registerTaskState endpoint
// NotFound error.
func NewRegisterTaskStateNotFound(body *RegisterTaskStateNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskStateInternalServerError builds a nft service
// registerTaskState endpoint InternalServerError error.
func NewRegisterTaskStateInternalServerError(body *RegisterTaskStateInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetTaskHistoryTaskHistoryOK builds a "nft" service "getTaskHistory"
// endpoint result from a HTTP "OK" response.
func NewGetTaskHistoryTaskHistoryOK(body []*TaskHistoryResponse) []*nft.TaskHistory {
	v := make([]*nft.TaskHistory, len(body))
	for i, val := range body {
		v[i] = unmarshalTaskHistoryResponseToNftTaskHistory(val)
	}

	return v
}

// NewGetTaskHistoryNotFound builds a nft service getTaskHistory endpoint
// NotFound error.
func NewGetTaskHistoryNotFound(body *GetTaskHistoryNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewGetTaskHistoryInternalServerError builds a nft service getTaskHistory
// endpoint InternalServerError error.
func NewGetTaskHistoryInternalServerError(body *GetTaskHistoryInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskTaskOK builds a "nft" service "registerTask" endpoint result
// from a HTTP "OK" response.
func NewRegisterTaskTaskOK(body *RegisterTaskResponseBody) *nftviews.TaskView {
	v := &nftviews.TaskView{
		ID:     body.ID,
		Status: body.Status,
		Txid:   body.Txid,
	}
	if body.States != nil {
		v.States = make([]*nftviews.TaskStateView, len(body.States))
		for i, val := range body.States {
			v.States[i] = unmarshalTaskStateResponseBodyToNftviewsTaskStateView(val)
		}
	}
	v.Ticket = unmarshalNftRegisterPayloadResponseBodyToNftviewsNftRegisterPayloadView(body.Ticket)

	return v
}

// NewRegisterTaskNotFound builds a nft service registerTask endpoint NotFound
// error.
func NewRegisterTaskNotFound(body *RegisterTaskNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskInternalServerError builds a nft service registerTask
// endpoint InternalServerError error.
func NewRegisterTaskInternalServerError(body *RegisterTaskInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTasksTaskCollectionOK builds a "nft" service "registerTasks"
// endpoint result from a HTTP "OK" response.
func NewRegisterTasksTaskCollectionOK(body RegisterTasksResponseBody) nftviews.TaskCollectionView {
	v := make([]*nftviews.TaskView, len(body))
	for i, val := range body {
		v[i] = unmarshalTaskResponseToNftviewsTaskView(val)
	}

	return v
}

// NewRegisterTasksInternalServerError builds a nft service registerTasks
// endpoint InternalServerError error.
func NewRegisterTasksInternalServerError(body *RegisterTasksInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUploadImageImageResCreated builds a "nft" service "uploadImage" endpoint
// result from a HTTP "Created" response.
func NewUploadImageImageResCreated(body *UploadImageResponseBody) *nftviews.ImageResView {
	v := &nftviews.ImageResView{
		ImageID:      body.ImageID,
		ExpiresIn:    body.ExpiresIn,
		EstimatedFee: body.EstimatedFee,
	}

	return v
}

// NewUploadImageBadRequest builds a nft service uploadImage endpoint
// BadRequest error.
func NewUploadImageBadRequest(body *UploadImageBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUploadImageInternalServerError builds a nft service uploadImage endpoint
// InternalServerError error.
func NewUploadImageInternalServerError(body *UploadImageInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftSearchResultOK builds a "nft" service "nftSearch" endpoint result from
// a HTTP "OK" response.
func NewNftSearchResultOK(body *NftSearchResponseBody) *nft.NftSearchResult {
	v := &nft.NftSearchResult{
		MatchIndex: *body.MatchIndex,
	}
	v.Nft = unmarshalNftSummaryResponseBodyToNftNftSummary(body.Nft)
	v.Matches = make([]*nft.FuzzyMatch, len(body.Matches))
	for i, val := range body.Matches {
		v.Matches[i] = unmarshalFuzzyMatchResponseBodyToNftFuzzyMatch(val)
	}

	return v
}

// NewNftSearchBadRequest builds a nft service nftSearch endpoint BadRequest
// error.
func NewNftSearchBadRequest(body *NftSearchBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftSearchInternalServerError builds a nft service nftSearch endpoint
// InternalServerError error.
func NewNftSearchInternalServerError(body *NftSearchInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftGetNftDetailOK builds a "nft" service "nftGet" endpoint result from a
// HTTP "OK" response.
func NewNftGetNftDetailOK(body *NftGetResponseBody) *nft.NftDetail {
	v := &nft.NftDetail{
		Version:                           body.Version,
		GreenAddress:                      body.GreenAddress,
		Royalty:                           body.Royalty,
		StorageFee:                        body.StorageFee,
		NsfwScore:                         *body.NsfwScore,
		RarenessScore:                     *body.RarenessScore,
		IsLikelyDupe:                      *body.IsLikelyDupe,
		IsRareOnInternet:                  *body.IsRareOnInternet,
		DrawingNsfwScore:                  body.DrawingNsfwScore,
		NeutralNsfwScore:                  body.NeutralNsfwScore,
		SexyNsfwScore:                     body.SexyNsfwScore,
		PornNsfwScore:                     body.PornNsfwScore,
		HentaiNsfwScore:                   body.HentaiNsfwScore,
		PreviewThumbnail:                  body.PreviewThumbnail,
		RareOnInternetSummaryTableJSONB64: body.RareOnInternetSummaryTableJSONB64,
		RareOnInternetGraphJSONB64:        body.RareOnInternetGraphJSONB64,
		AltRareOnInternetDictJSONB64:      body.AltRareOnInternetDictJSONB64,
		MinNumExactMatchesOnPage:          body.MinNumExactMatchesOnPage,
		EarliestDateOfResults:             body.EarliestDateOfResults,
		Thumbnail1:                        body.Thumbnail1,
		Thumbnail2:                        body.Thumbnail2,
		Txid:                              *body.Txid,
		Title:                             *body.Title,
		Description:                       *body.Description,
		Keywords:                          body.Keywords,
		SeriesName:                        body.SeriesName,
		Copies:                            *body.Copies,
		YoutubeURL:                        body.YoutubeURL,
		CreatorPastelID:                   *body.CreatorPastelID,
		CreatorName:                       *body.CreatorName,
		CreatorWebsiteURL:                 body.CreatorWebsiteURL,
	}

	return v
}

// NewNftGetBadRequest builds a nft service nftGet endpoint BadRequest error.
func NewNftGetBadRequest(body *NftGetBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftGetNotFound builds a nft service nftGet endpoint NotFound error.
func NewNftGetNotFound(body *NftGetNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftGetInternalServerError builds a nft service nftGet endpoint
// InternalServerError error.
func NewNftGetInternalServerError(body *NftGetInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDownloadFileDownloadResultOK builds a "nft" service "download" endpoint
// result from a HTTP "OK" response.
func NewDownloadFileDownloadResultOK(body *DownloadResponseBody) *nft.FileDownloadResult {
	v := &nft.FileDownloadResult{
		FileID: *body.FileID,
	}

	return v
}

// NewDownloadNotFound builds a nft service download endpoint NotFound error.
func NewDownloadNotFound(body *DownloadNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDownloadInternalServerError builds a nft service download endpoint
// InternalServerError error.
func NewDownloadInternalServerError(body *DownloadInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDdServiceOutputFileDetailDDServiceOutputFileResultOK builds a "nft"
// service "ddServiceOutputFileDetail" endpoint result from a HTTP "OK"
// response.
func NewDdServiceOutputFileDetailDDServiceOutputFileResultOK(body *DdServiceOutputFileDetailResponseBody) *nft.DDServiceOutputFileResult {
	v := &nft.DDServiceOutputFileResult{
		PastelBlockHashWhenRequestSubmitted:         body.PastelBlockHashWhenRequestSubmitted,
		PastelBlockHeightWhenRequestSubmitted:       body.PastelBlockHeightWhenRequestSubmitted,
		UtcTimestampWhenRequestSubmitted:            body.UtcTimestampWhenRequestSubmitted,
		PastelIDOfSubmitter:                         body.PastelIDOfSubmitter,
		PastelIDOfRegisteringSupernode1:             body.PastelIDOfRegisteringSupernode1,
		PastelIDOfRegisteringSupernode2:             body.PastelIDOfRegisteringSupernode2,
		PastelIDOfRegisteringSupernode3:             body.PastelIDOfRegisteringSupernode3,
		IsPastelOpenapiRequest:                      body.IsPastelOpenapiRequest,
		DupeDetectionSystemVersion:                  body.DupeDetectionSystemVersion,
		IsLikelyDupe:                                body.IsLikelyDupe,
		IsRareOnInternet:                            body.IsRareOnInternet,
		OverallRarenessScore:                        body.OverallRarenessScore,
		PctOfTop10MostSimilarWithDupeProbAbove25pct: body.PctOfTop10MostSimilarWithDupeProbAbove25pct,
		PctOfTop10MostSimilarWithDupeProbAbove33pct: body.PctOfTop10MostSimilarWithDupeProbAbove33pct,
		PctOfTop10MostSimilarWithDupeProbAbove50pct: body.PctOfTop10MostSimilarWithDupeProbAbove50pct,
		RarenessScoresTableJSONCompressedB64:        body.RarenessScoresTableJSONCompressedB64,
		OpenNsfwScore:                               body.OpenNsfwScore,
		HashOfCandidateImageFile:                    body.HashOfCandidateImageFile,
		CollectionNameString:                        body.CollectionNameString,
		OpenAPIGroupIDString:                        body.OpenAPIGroupIDString,
		GroupRarenessScore:                          body.GroupRarenessScore,
		CandidateImageThumbnailWebpAsBase64String:   body.CandidateImageThumbnailWebpAsBase64String,
		DoesNotImpactTheFollowingCollectionStrings:  body.DoesNotImpactTheFollowingCollectionStrings,
		SimilarityScoreToFirstEntryInCollection:     body.SimilarityScoreToFirstEntryInCollection,
		CpProbability:                               body.CpProbability,
		ChildProbability:                            body.ChildProbability,
		ImageFilePath:                               body.ImageFilePath,
		CreatorName:                                 *body.CreatorName,
		CreatorWebsite:                              *body.CreatorWebsite,
		CreatorWrittenStatement:                     *body.CreatorWrittenStatement,
		NftTitle:                                    *body.NftTitle,
		NftSeriesName:                               *body.NftSeriesName,
		NftCreationVideoYoutubeURL:                  *body.NftCreationVideoYoutubeURL,
		NftKeywordSet:                               *body.NftKeywordSet,
		TotalCopies:                                 *body.TotalCopies,
		PreviewHash:                                 body.PreviewHash,
		Thumbnail1Hash:                              body.Thumbnail1Hash,
		Thumbnail2Hash:                              body.Thumbnail2Hash,
		OriginalFileSizeInBytes:                     *body.OriginalFileSizeInBytes,
		FileType:                                    *body.FileType,
		MaxPermittedOpenNsfwScore:                   *body.MaxPermittedOpenNsfwScore,
	}
	if body.ImageFingerprintOfCandidateImageFile != nil {
		v.ImageFingerprintOfCandidateImageFile = make([]float64, len(body.ImageFingerprintOfCandidateImageFile))
		for i, val := range body.ImageFingerprintOfCandidateImageFile {
			v.ImageFingerprintOfCandidateImageFile[i] = val
		}
	}
	if body.InternetRareness != nil {
		v.InternetRareness = unmarshalInternetRarenessResponseBodyToNftInternetRareness(body.InternetRareness)
	}
	if body.AlternativeNsfwScores != nil {
		v.AlternativeNsfwScores = unmarshalAlternativeNSFWScoresResponseBodyToNftAlternativeNSFWScores(body.AlternativeNsfwScores)
	}

	return v
}

// NewDdServiceOutputFileDetailNotFound builds a nft service
// ddServiceOutputFileDetail endpoint NotFound error.
func NewDdServiceOutputFileDetailNotFound(body *DdServiceOutputFileDetailNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDdServiceOutputFileDetailInternalServerError builds a nft service
// ddServiceOutputFileDetail endpoint InternalServerError error.
func NewDdServiceOutputFileDetailInternalServerError(body *DdServiceOutputFileDetailInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDdServiceOutputFileDDFPResultFileOK builds a "nft" service
// "ddServiceOutputFile" endpoint result from a HTTP "OK" response.
func NewDdServiceOutputFileDDFPResultFileOK(body *DdServiceOutputFileResponseBody) *nft.DDFPResultFile {
	v := &nft.DDFPResultFile{
		File: *body.File,
	}

	return v
}

// NewDdServiceOutputFileNotFound builds a nft service ddServiceOutputFile
// endpoint NotFound error.
func NewDdServiceOutputFileNotFound(body *DdServiceOutputFileNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDdServiceOutputFileInternalServerError builds a nft service
// ddServiceOutputFile endpoint InternalServerError error.
func NewDdServiceOutputFileInternalServerError(body *DdServiceOutputFileInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// ValidateRegisterTaskStateResponseBody runs the validations defined on
// RegisterTaskStateResponseBody
func ValidateRegisterTaskStateResponseBody(body *RegisterTaskStateResponseBody) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Validating Duplicate Reg Tickets" || *body.Status == "Validating Burn Txn" || *body.Status == "Burn Txn Validated" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Setting up mesh of supernodes" || *body.Status == "Error Sending Reg Metadata" || *body.Status == "Error Uploading Image" || *body.Status == "Error Converting Image to Bytes" || *body.Status == "Error Encoding Image" || *body.Status == "Error Creating Ticket" || *body.Status == "Error Signing Ticket" || *body.Status == "Error Uploading Ticket" || *body.Status == "Error Activating Ticket" || *body.Status == "Error Probing Image" || *body.Status == "Error checking dd-server availability before probe image" || *body.Status == "Error Generating DD and Fingerprint IDs" || *body.Status == "Error comparing suitable storage fee with task request maximum fee" || *body.Status == "Error balance not sufficient" || *body.Status == "Error getting hash of the image" || *body.Status == "Error sending signed ticket to SNs" || *body.Status == "Error checking balance" || *body.Status == "Error burning reg fee to get reg ticket id" || *body.Status == "Error validating reg ticket txn id" || *body.Status == "Error validating activate ticket txn id" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"Task Started", "Connected", "Validating Duplicate Reg Tickets", "Validating Burn Txn", "Burn Txn Validated", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Setting up mesh of supernodes", "Error Sending Reg Metadata", "Error Uploading Image", "Error Converting Image to Bytes", "Error Encoding Image", "Error Creating Ticket", "Error Signing Ticket", "Error Uploading Ticket", "Error Activating Ticket", "Error Probing Image", "Error checking dd-server availability before probe image", "Error Generating DD and Fingerprint IDs", "Error comparing suitable storage fee with task request maximum fee", "Error balance not sufficient", "Error getting hash of the image", "Error sending signed ticket to SNs", "Error checking balance", "Error burning reg fee to get reg ticket id", "Error validating reg ticket txn id", "Error validating activate ticket txn id", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateNftSearchResponseBody runs the validations defined on
// NftSearchResponseBody
func ValidateNftSearchResponseBody(body *NftSearchResponseBody) (err error) {
	if body.Nft == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nft", "body"))
	}
	if body.Matches == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("matches", "body"))
	}
	if body.MatchIndex == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("match_index", "body"))
	}
	if body.Nft != nil {
		if err2 := ValidateNftSummaryResponseBody(body.Nft); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Matches {
		if e != nil {
			if err2 := ValidateFuzzyMatchResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateNftGetResponseBody runs the validations defined on NftGetResponseBody
func ValidateNftGetResponseBody(body *NftGetResponseBody) (err error) {
	if body.RarenessScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("rareness_score", "body"))
	}
	if body.NsfwScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nsfw_score", "body"))
	}
	if body.IsLikelyDupe == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("is_likely_dupe", "body"))
	}
	if body.IsRareOnInternet == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("is_rare_on_internet", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Copies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("copies", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.Txid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txid", "body"))
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 0, true))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 1, false))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 0, true))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 1, false))
		}
	}
	if body.DrawingNsfwScore != nil {
		if *body.DrawingNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.drawing_nsfw_score", *body.DrawingNsfwScore, 0, true))
		}
	}
	if body.DrawingNsfwScore != nil {
		if *body.DrawingNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.drawing_nsfw_score", *body.DrawingNsfwScore, 1, false))
		}
	}
	if body.NeutralNsfwScore != nil {
		if *body.NeutralNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.neutral_nsfw_score", *body.NeutralNsfwScore, 0, true))
		}
	}
	if body.NeutralNsfwScore != nil {
		if *body.NeutralNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.neutral_nsfw_score", *body.NeutralNsfwScore, 1, false))
		}
	}
	if body.SexyNsfwScore != nil {
		if *body.SexyNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.sexy_nsfw_score", *body.SexyNsfwScore, 0, true))
		}
	}
	if body.SexyNsfwScore != nil {
		if *body.SexyNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.sexy_nsfw_score", *body.SexyNsfwScore, 1, false))
		}
	}
	if body.PornNsfwScore != nil {
		if *body.PornNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.porn_nsfw_score", *body.PornNsfwScore, 0, true))
		}
	}
	if body.PornNsfwScore != nil {
		if *body.PornNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.porn_nsfw_score", *body.PornNsfwScore, 1, false))
		}
	}
	if body.HentaiNsfwScore != nil {
		if *body.HentaiNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hentai_nsfw_score", *body.HentaiNsfwScore, 0, true))
		}
	}
	if body.HentaiNsfwScore != nil {
		if *body.HentaiNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hentai_nsfw_score", *body.HentaiNsfwScore, 1, false))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.Copies != nil {
		if *body.Copies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1, true))
		}
	}
	if body.Copies != nil {
		if *body.Copies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	return
}

// ValidateDownloadResponseBody runs the validations defined on
// DownloadResponseBody
func ValidateDownloadResponseBody(body *DownloadResponseBody) (err error) {
	if body.FileID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("file_id", "body"))
	}
	return
}

// ValidateDdServiceOutputFileDetailResponseBody runs the validations defined
// on DdServiceOutputFileDetailResponseBody
func ValidateDdServiceOutputFileDetailResponseBody(body *DdServiceOutputFileDetailResponseBody) (err error) {
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.CreatorWebsite == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_website", "body"))
	}
	if body.CreatorWrittenStatement == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_written_statement", "body"))
	}
	if body.NftTitle == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nft_title", "body"))
	}
	if body.NftSeriesName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nft_series_name", "body"))
	}
	if body.NftCreationVideoYoutubeURL == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nft_creation_video_youtube_url", "body"))
	}
	if body.NftKeywordSet == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nft_keyword_set", "body"))
	}
	if body.TotalCopies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("total_copies", "body"))
	}
	if body.PreviewHash == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("preview_hash", "body"))
	}
	if body.Thumbnail1Hash == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("thumbnail1_hash", "body"))
	}
	if body.Thumbnail2Hash == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("thumbnail2_hash", "body"))
	}
	if body.OriginalFileSizeInBytes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("original_file_size_in_bytes", "body"))
	}
	if body.FileType == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("file_type", "body"))
	}
	if body.MaxPermittedOpenNsfwScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("max_permitted_open_nsfw_score", "body"))
	}
	return
}

// ValidateDdServiceOutputFileResponseBody runs the validations defined on
// DdServiceOutputFileResponseBody
func ValidateDdServiceOutputFileResponseBody(body *DdServiceOutputFileResponseBody) (err error) {
	if body.File == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("file", "body"))
	}
	return
}

// ValidateRegisterBadRequestResponseBody runs the validations defined on
// register_BadRequest_response_body
func ValidateRegisterBadRequestResponseBody(body *RegisterBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterInternalServerErrorResponseBody runs the validations defined
// on register_InternalServerError_response_body
func ValidateRegisterInternalServerErrorResponseBody(body *RegisterInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskStateNotFoundResponseBody runs the validations defined
// on registerTaskState_NotFound_response_body
func ValidateRegisterTaskStateNotFoundResponseBody(body *RegisterTaskStateNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskStateInternalServerErrorResponseBody runs the
// validations defined on registerTaskState_InternalServerError_response_body
func ValidateRegisterTaskStateInternalServerErrorResponseBody(body *RegisterTaskStateInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetTaskHistoryNotFoundResponseBody runs the validations defined on
// getTaskHistory_NotFound_response_body
func ValidateGetTaskHistoryNotFoundResponseBody(body *GetTaskHistoryNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateGetTaskHistoryInternalServerErrorResponseBody runs the validations
// defined on getTaskHistory_InternalServerError_response_body
func ValidateGetTaskHistoryInternalServerErrorResponseBody(body *GetTaskHistoryInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskNotFoundResponseBody runs the validations defined on
// registerTask_NotFound_response_body
func ValidateRegisterTaskNotFoundResponseBody(body *RegisterTaskNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskInternalServerErrorResponseBody runs the validations
// defined on registerTask_InternalServerError_response_body
func ValidateRegisterTaskInternalServerErrorResponseBody(body *RegisterTaskInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTasksInternalServerErrorResponseBody runs the validations
// defined on registerTasks_InternalServerError_response_body
func ValidateRegisterTasksInternalServerErrorResponseBody(body *RegisterTasksInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUploadImageBadRequestResponseBody runs the validations defined on
// uploadImage_BadRequest_response_body
func ValidateUploadImageBadRequestResponseBody(body *UploadImageBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUploadImageInternalServerErrorResponseBody runs the validations
// defined on uploadImage_InternalServerError_response_body
func ValidateUploadImageInternalServerErrorResponseBody(body *UploadImageInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftSearchBadRequestResponseBody runs the validations defined on
// nftSearch_BadRequest_response_body
func ValidateNftSearchBadRequestResponseBody(body *NftSearchBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftSearchInternalServerErrorResponseBody runs the validations
// defined on nftSearch_InternalServerError_response_body
func ValidateNftSearchInternalServerErrorResponseBody(body *NftSearchInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftGetBadRequestResponseBody runs the validations defined on
// nftGet_BadRequest_response_body
func ValidateNftGetBadRequestResponseBody(body *NftGetBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftGetNotFoundResponseBody runs the validations defined on
// nftGet_NotFound_response_body
func ValidateNftGetNotFoundResponseBody(body *NftGetNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftGetInternalServerErrorResponseBody runs the validations defined
// on nftGet_InternalServerError_response_body
func ValidateNftGetInternalServerErrorResponseBody(body *NftGetInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDownloadNotFoundResponseBody runs the validations defined on
// download_NotFound_response_body
func ValidateDownloadNotFoundResponseBody(body *DownloadNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDownloadInternalServerErrorResponseBody runs the validations defined
// on download_InternalServerError_response_body
func ValidateDownloadInternalServerErrorResponseBody(body *DownloadInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDdServiceOutputFileDetailNotFoundResponseBody runs the validations
// defined on ddServiceOutputFileDetail_NotFound_response_body
func ValidateDdServiceOutputFileDetailNotFoundResponseBody(body *DdServiceOutputFileDetailNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDdServiceOutputFileDetailInternalServerErrorResponseBody runs the
// validations defined on
// ddServiceOutputFileDetail_InternalServerError_response_body
func ValidateDdServiceOutputFileDetailInternalServerErrorResponseBody(body *DdServiceOutputFileDetailInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDdServiceOutputFileNotFoundResponseBody runs the validations defined
// on ddServiceOutputFile_NotFound_response_body
func ValidateDdServiceOutputFileNotFoundResponseBody(body *DdServiceOutputFileNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDdServiceOutputFileInternalServerErrorResponseBody runs the
// validations defined on ddServiceOutputFile_InternalServerError_response_body
func ValidateDdServiceOutputFileInternalServerErrorResponseBody(body *DdServiceOutputFileInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateTaskHistoryResponse runs the validations defined on
// TaskHistoryResponse
func ValidateTaskHistoryResponse(body *TaskHistoryResponse) (err error) {
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	return
}

// ValidateTaskStateResponseBody runs the validations defined on
// TaskStateResponseBody
func ValidateTaskStateResponseBody(body *TaskStateResponseBody) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Validating Duplicate Reg Tickets" || *body.Status == "Validating Burn Txn" || *body.Status == "Burn Txn Validated" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Setting up mesh of supernodes" || *body.Status == "Error Sending Reg Metadata" || *body.Status == "Error Uploading Image" || *body.Status == "Error Converting Image to Bytes" || *body.Status == "Error Encoding Image" || *body.Status == "Error Creating Ticket" || *body.Status == "Error Signing Ticket" || *body.Status == "Error Uploading Ticket" || *body.Status == "Error Activating Ticket" || *body.Status == "Error Probing Image" || *body.Status == "Error checking dd-server availability before probe image" || *body.Status == "Error Generating DD and Fingerprint IDs" || *body.Status == "Error comparing suitable storage fee with task request maximum fee" || *body.Status == "Error balance not sufficient" || *body.Status == "Error getting hash of the image" || *body.Status == "Error sending signed ticket to SNs" || *body.Status == "Error checking balance" || *body.Status == "Error burning reg fee to get reg ticket id" || *body.Status == "Error validating reg ticket txn id" || *body.Status == "Error validating activate ticket txn id" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"Task Started", "Connected", "Validating Duplicate Reg Tickets", "Validating Burn Txn", "Burn Txn Validated", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Setting up mesh of supernodes", "Error Sending Reg Metadata", "Error Uploading Image", "Error Converting Image to Bytes", "Error Encoding Image", "Error Creating Ticket", "Error Signing Ticket", "Error Uploading Ticket", "Error Activating Ticket", "Error Probing Image", "Error checking dd-server availability before probe image", "Error Generating DD and Fingerprint IDs", "Error comparing suitable storage fee with task request maximum fee", "Error balance not sufficient", "Error getting hash of the image", "Error sending signed ticket to SNs", "Error checking balance", "Error burning reg fee to get reg ticket id", "Error validating reg ticket txn id", "Error validating activate ticket txn id", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateNftRegisterPayloadResponseBody runs the validations defined on
// NftRegisterPayloadResponseBody
func ValidateNftRegisterPayloadResponseBody(body *NftRegisterPayloadResponseBody) (err error) {
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.SpendableAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spendable_address", "body"))
	}
	if body.MaximumFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("maximum_fee", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	if body.SpendableAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spendable_address", *body.SpendableAddress, "^[a-zA-Z0-9]+$"))
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) < 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, true))
		}
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) > 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, false))
		}
	}
	if body.MaximumFee != nil {
		if *body.MaximumFee < 1e-05 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.maximum_fee", *body.MaximumFee, 1e-05, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty > 20 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 20, false))
		}
	}
	if body.ThumbnailCoordinate != nil {
		if err2 := ValidateThumbnailcoordinateResponseBody(body.ThumbnailCoordinate); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateThumbnailcoordinateResponseBody runs the validations defined on
// ThumbnailcoordinateResponseBody
func ValidateThumbnailcoordinateResponseBody(body *ThumbnailcoordinateResponseBody) (err error) {
	if body.TopLeftX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_x", "body"))
	}
	if body.TopLeftY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_y", "body"))
	}
	if body.BottomRightX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_x", "body"))
	}
	if body.BottomRightY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_y", "body"))
	}
	return
}

// ValidateTaskResponse runs the validations defined on TaskResponse
func ValidateTaskResponse(body *TaskResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Ticket == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ticket", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 8, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 8, false))
		}
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Validating Duplicate Reg Tickets" || *body.Status == "Validating Burn Txn" || *body.Status == "Burn Txn Validated" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Setting up mesh of supernodes" || *body.Status == "Error Sending Reg Metadata" || *body.Status == "Error Uploading Image" || *body.Status == "Error Converting Image to Bytes" || *body.Status == "Error Encoding Image" || *body.Status == "Error Creating Ticket" || *body.Status == "Error Signing Ticket" || *body.Status == "Error Uploading Ticket" || *body.Status == "Error Activating Ticket" || *body.Status == "Error Probing Image" || *body.Status == "Error checking dd-server availability before probe image" || *body.Status == "Error Generating DD and Fingerprint IDs" || *body.Status == "Error comparing suitable storage fee with task request maximum fee" || *body.Status == "Error balance not sufficient" || *body.Status == "Error getting hash of the image" || *body.Status == "Error sending signed ticket to SNs" || *body.Status == "Error checking balance" || *body.Status == "Error burning reg fee to get reg ticket id" || *body.Status == "Error validating reg ticket txn id" || *body.Status == "Error validating activate ticket txn id" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"Task Started", "Connected", "Validating Duplicate Reg Tickets", "Validating Burn Txn", "Burn Txn Validated", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Setting up mesh of supernodes", "Error Sending Reg Metadata", "Error Uploading Image", "Error Converting Image to Bytes", "Error Encoding Image", "Error Creating Ticket", "Error Signing Ticket", "Error Uploading Ticket", "Error Activating Ticket", "Error Probing Image", "Error checking dd-server availability before probe image", "Error Generating DD and Fingerprint IDs", "Error comparing suitable storage fee with task request maximum fee", "Error balance not sufficient", "Error getting hash of the image", "Error sending signed ticket to SNs", "Error checking balance", "Error burning reg fee to get reg ticket id", "Error validating reg ticket txn id", "Error validating activate ticket txn id", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	for _, e := range body.States {
		if e != nil {
			if err2 := ValidateTaskStateResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Ticket != nil {
		if err2 := ValidateNftRegisterPayloadResponse(body.Ticket); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateTaskStateResponse runs the validations defined on TaskStateResponse
func ValidateTaskStateResponse(body *TaskStateResponse) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Validating Duplicate Reg Tickets" || *body.Status == "Validating Burn Txn" || *body.Status == "Burn Txn Validated" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Setting up mesh of supernodes" || *body.Status == "Error Sending Reg Metadata" || *body.Status == "Error Uploading Image" || *body.Status == "Error Converting Image to Bytes" || *body.Status == "Error Encoding Image" || *body.Status == "Error Creating Ticket" || *body.Status == "Error Signing Ticket" || *body.Status == "Error Uploading Ticket" || *body.Status == "Error Activating Ticket" || *body.Status == "Error Probing Image" || *body.Status == "Error checking dd-server availability before probe image" || *body.Status == "Error Generating DD and Fingerprint IDs" || *body.Status == "Error comparing suitable storage fee with task request maximum fee" || *body.Status == "Error balance not sufficient" || *body.Status == "Error getting hash of the image" || *body.Status == "Error sending signed ticket to SNs" || *body.Status == "Error checking balance" || *body.Status == "Error burning reg fee to get reg ticket id" || *body.Status == "Error validating reg ticket txn id" || *body.Status == "Error validating activate ticket txn id" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []any{"Task Started", "Connected", "Validating Duplicate Reg Tickets", "Validating Burn Txn", "Burn Txn Validated", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Setting up mesh of supernodes", "Error Sending Reg Metadata", "Error Uploading Image", "Error Converting Image to Bytes", "Error Encoding Image", "Error Creating Ticket", "Error Signing Ticket", "Error Uploading Ticket", "Error Activating Ticket", "Error Probing Image", "Error checking dd-server availability before probe image", "Error Generating DD and Fingerprint IDs", "Error comparing suitable storage fee with task request maximum fee", "Error balance not sufficient", "Error getting hash of the image", "Error sending signed ticket to SNs", "Error checking balance", "Error burning reg fee to get reg ticket id", "Error validating reg ticket txn id", "Error validating activate ticket txn id", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateNftRegisterPayloadResponse runs the validations defined on
// NftRegisterPayloadResponse
func ValidateNftRegisterPayloadResponse(body *NftRegisterPayloadResponse) (err error) {
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.SpendableAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spendable_address", "body"))
	}
	if body.MaximumFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("maximum_fee", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	if body.SpendableAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spendable_address", *body.SpendableAddress, "^[a-zA-Z0-9]+$"))
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) < 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, true))
		}
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) > 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, false))
		}
	}
	if body.MaximumFee != nil {
		if *body.MaximumFee < 1e-05 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.maximum_fee", *body.MaximumFee, 1e-05, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty > 20 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 20, false))
		}
	}
	if body.ThumbnailCoordinate != nil {
		if err2 := ValidateThumbnailcoordinateResponse(body.ThumbnailCoordinate); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateThumbnailcoordinateResponse runs the validations defined on
// ThumbnailcoordinateResponse
func ValidateThumbnailcoordinateResponse(body *ThumbnailcoordinateResponse) (err error) {
	if body.TopLeftX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_x", "body"))
	}
	if body.TopLeftY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_y", "body"))
	}
	if body.BottomRightX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_x", "body"))
	}
	if body.BottomRightY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_y", "body"))
	}
	return
}

// ValidateNftSummaryResponseBody runs the validations defined on
// NftSummaryResponseBody
func ValidateNftSummaryResponseBody(body *NftSummaryResponseBody) (err error) {
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Copies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("copies", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.Txid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txid", "body"))
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.Copies != nil {
		if *body.Copies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1, true))
		}
	}
	if body.Copies != nil {
		if *body.Copies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 0, true))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 1, false))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 0, true))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 1, false))
		}
	}
	return
}

// ValidateFuzzyMatchResponseBody runs the validations defined on
// FuzzyMatchResponseBody
func ValidateFuzzyMatchResponseBody(body *FuzzyMatchResponseBody) (err error) {
	if body.FieldType != nil {
		if !(*body.FieldType == "creator_name" || *body.FieldType == "art_title" || *body.FieldType == "series" || *body.FieldType == "descr" || *body.FieldType == "keyword") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.field_type", *body.FieldType, []any{"creator_name", "art_title", "series", "descr", "keyword"}))
		}
	}
	return
}

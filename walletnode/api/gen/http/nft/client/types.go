// Code generated by goa v3.4.3, DO NOT EDIT.
//
// nft HTTP client types
//
// Command:
// $ goa gen github.com/pastelnetwork/gonode/walletnode/api/design -o api/

package client

import (
	"unicode/utf8"

	nft "github.com/pastelnetwork/gonode/walletnode/api/gen/nft"
	nftviews "github.com/pastelnetwork/gonode/walletnode/api/gen/nft/views"
	goa "goa.design/goa/v3/pkg"
)

// RegisterRequestBody is the type of the "nft" service "register" endpoint
// HTTP request body.
type RegisterRequestBody struct {
	// Uploaded image ID
	ImageID string `form:"image_id" json:"image_id" xml:"image_id"`
	// Name of the NFT
	Name string `form:"name" json:"name" xml:"name"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies int `form:"issued_copies" json:"issued_copies" xml:"issued_copies"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Creator's PastelID
	CreatorPastelID string `form:"creator_pastelid" json:"creator_pastelid" xml:"creator_pastelid"`
	// Passphrase of the artist's PastelID
	CreatorPastelIDPassphrase string `form:"creator_pastelid_passphrase" json:"creator_pastelid_passphrase" xml:"creator_pastelid_passphrase"`
	// Name of the NFT creator
	CreatorName string `form:"creator_name" json:"creator_name" xml:"creator_name"`
	// NFT creator website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// Spendable address
	SpendableAddress string `form:"spendable_address" json:"spendable_address" xml:"spendable_address"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee float64 `form:"maximum_fee" json:"maximum_fee" xml:"maximum_fee"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty float64 `form:"royalty" json:"royalty" xml:"royalty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               bool                            `form:"green" json:"green" xml:"green"`
	ThumbnailCoordinate *ThumbnailcoordinateRequestBody `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
}

// UploadImageRequestBody is the type of the "nft" service "uploadImage"
// endpoint HTTP request body.
type UploadImageRequestBody struct {
	// File to upload
	Bytes []byte `form:"file" json:"file" xml:"file"`
	// For internal use
	Filename *string `form:"filename,omitempty" json:"filename,omitempty" xml:"filename,omitempty"`
}

// NftGetRequestBody is the type of the "nft" service "nftGet" endpoint HTTP
// request body.
type NftGetRequestBody struct {
	// User's PastelID
	UserPastelID string `form:"user_pastelid" json:"user_pastelid" xml:"user_pastelid"`
	// Passphrase of the User PastelID
	UserPassphrase string `form:"user_passphrase" json:"user_passphrase" xml:"user_passphrase"`
}

// RegisterResponseBody is the type of the "nft" service "register" endpoint
// HTTP response body.
type RegisterResponseBody struct {
	// Task ID of the registration process
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
}

// RegisterTaskStateResponseBody is the type of the "nft" service
// "registerTaskState" endpoint HTTP response body.
type RegisterTaskStateResponseBody struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// RegisterTaskResponseBody is the type of the "nft" service "registerTask"
// endpoint HTTP response body.
type RegisterTaskResponseBody struct {
	// JOb ID of the registration process
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of states from the very beginning of the process
	States []*TaskStateResponseBody `form:"states,omitempty" json:"states,omitempty" xml:"states,omitempty"`
	// txid
	Txid   *string                         `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	Ticket *NftRegisterPayloadResponseBody `form:"ticket,omitempty" json:"ticket,omitempty" xml:"ticket,omitempty"`
}

// RegisterTasksResponseBody is the type of the "nft" service "registerTasks"
// endpoint HTTP response body.
type RegisterTasksResponseBody []*TaskResponse

// UploadImageResponseBody is the type of the "nft" service "uploadImage"
// endpoint HTTP response body.
type UploadImageResponseBody struct {
	// Uploaded image ID
	ImageID *string `form:"image_id,omitempty" json:"image_id,omitempty" xml:"image_id,omitempty"`
	// Image expiration
	ExpiresIn *string `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
}

// NftSearchResponseBody is the type of the "nft" service "nftSearch" endpoint
// HTTP response body.
type NftSearchResponseBody struct {
	// NFT data
	Nft *NftSummaryResponseBody `form:"nft,omitempty" json:"nft,omitempty" xml:"nft,omitempty"`
	// Sort index of the match based on score.This must be used to sort results on
	// UI.
	MatchIndex *int `form:"match_index,omitempty" json:"match_index,omitempty" xml:"match_index,omitempty"`
	// Match result details
	Matches []*FuzzyMatchResponseBody `form:"matches,omitempty" json:"matches,omitempty" xml:"matches,omitempty"`
}

// NftGetResponseBody is the type of the "nft" service "nftGet" endpoint HTTP
// response body.
type NftGetResponseBody struct {
	// version
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// Green address
	GreenAddress *bool `form:"green_address,omitempty" json:"green_address,omitempty" xml:"green_address,omitempty"`
	// how much artist should get on all future resales
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// Storage fee %
	StorageFee *int `form:"storage_fee,omitempty" json:"storage_fee,omitempty" xml:"storage_fee,omitempty"`
	// NSFW Average score
	NsfwScore *float32 `form:"nsfw_score,omitempty" json:"nsfw_score,omitempty" xml:"nsfw_score,omitempty"`
	// Average pastel rareness score
	RarenessScore *float32 `form:"rareness_score,omitempty" json:"rareness_score,omitempty" xml:"rareness_score,omitempty"`
	// Is this image likely a duplicate of another known image
	IsLikelyDupe *bool `form:"is_likely_dupe,omitempty" json:"is_likely_dupe,omitempty" xml:"is_likely_dupe,omitempty"`
	// How many matches the scraper found on the first page of the google results
	MatchesFoundOnFirstPage *uint32 `form:"matches_found_on_first_page,omitempty" json:"matches_found_on_first_page,omitempty" xml:"matches_found_on_first_page,omitempty"`
	// How many pages of search results the scraper found when searching for this
	// image
	NumberOfPagesOfResults *uint32 `form:"number_of_pages_of_results,omitempty" json:"number_of_pages_of_results,omitempty" xml:"number_of_pages_of_results,omitempty"`
	// URL of the first match on the first page of search results
	URLOfFirstMatchInPage *string `form:"URL_of_first_match_in_page,omitempty" json:"URL_of_first_match_in_page,omitempty" xml:"URL_of_first_match_in_page,omitempty"`
	// nsfw score
	DrawingNsfwScore *float32 `form:"drawing_nsfw_score,omitempty" json:"drawing_nsfw_score,omitempty" xml:"drawing_nsfw_score,omitempty"`
	// nsfw score
	NeutralNsfwScore *float32 `form:"neutral_nsfw_score,omitempty" json:"neutral_nsfw_score,omitempty" xml:"neutral_nsfw_score,omitempty"`
	// nsfw score
	SexyNsfwScore *float32 `form:"sexy_nsfw_score,omitempty" json:"sexy_nsfw_score,omitempty" xml:"sexy_nsfw_score,omitempty"`
	// nsfw score
	PornNsfwScore *float32 `form:"porn_nsfw_score,omitempty" json:"porn_nsfw_score,omitempty" xml:"porn_nsfw_score,omitempty"`
	// nsfw score
	HentaiNsfwScore *float32 `form:"hentai_nsfw_score,omitempty" json:"hentai_nsfw_score,omitempty" xml:"hentai_nsfw_score,omitempty"`
	// Preview Image
	PreviewThumbnail []byte `form:"preview_thumbnail,omitempty" json:"preview_thumbnail,omitempty" xml:"preview_thumbnail,omitempty"`
	// Thumbnail_1 image
	Thumbnail1 []byte `form:"thumbnail_1,omitempty" json:"thumbnail_1,omitempty" xml:"thumbnail_1,omitempty"`
	// Thumbnail_2 image
	Thumbnail2 []byte `form:"thumbnail_2,omitempty" json:"thumbnail_2,omitempty" xml:"thumbnail_2,omitempty"`
	// txid
	Txid *string `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	// Name of the NFT
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies
	Copies *int `form:"copies,omitempty" json:"copies,omitempty" xml:"copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Name of the artist
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// Artist website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
}

// DownloadResponseBody is the type of the "nft" service "download" endpoint
// HTTP response body.
type DownloadResponseBody struct {
	// File downloaded
	File []byte `form:"file,omitempty" json:"file,omitempty" xml:"file,omitempty"`
}

// RegisterBadRequestResponseBody is the type of the "nft" service "register"
// endpoint HTTP response body for the "BadRequest" error.
type RegisterBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterInternalServerErrorResponseBody is the type of the "nft" service
// "register" endpoint HTTP response body for the "InternalServerError" error.
type RegisterInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskStateNotFoundResponseBody is the type of the "nft" service
// "registerTaskState" endpoint HTTP response body for the "NotFound" error.
type RegisterTaskStateNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskStateInternalServerErrorResponseBody is the type of the "nft"
// service "registerTaskState" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTaskStateInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskNotFoundResponseBody is the type of the "nft" service
// "registerTask" endpoint HTTP response body for the "NotFound" error.
type RegisterTaskNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskInternalServerErrorResponseBody is the type of the "nft" service
// "registerTask" endpoint HTTP response body for the "InternalServerError"
// error.
type RegisterTaskInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTasksInternalServerErrorResponseBody is the type of the "nft"
// service "registerTasks" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTasksInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UploadImageBadRequestResponseBody is the type of the "nft" service
// "uploadImage" endpoint HTTP response body for the "BadRequest" error.
type UploadImageBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UploadImageInternalServerErrorResponseBody is the type of the "nft" service
// "uploadImage" endpoint HTTP response body for the "InternalServerError"
// error.
type UploadImageInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftSearchBadRequestResponseBody is the type of the "nft" service "nftSearch"
// endpoint HTTP response body for the "BadRequest" error.
type NftSearchBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftSearchInternalServerErrorResponseBody is the type of the "nft" service
// "nftSearch" endpoint HTTP response body for the "InternalServerError" error.
type NftSearchInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftGetBadRequestResponseBody is the type of the "nft" service "nftGet"
// endpoint HTTP response body for the "BadRequest" error.
type NftGetBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftGetNotFoundResponseBody is the type of the "nft" service "nftGet"
// endpoint HTTP response body for the "NotFound" error.
type NftGetNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// NftGetInternalServerErrorResponseBody is the type of the "nft" service
// "nftGet" endpoint HTTP response body for the "InternalServerError" error.
type NftGetInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DownloadNotFoundResponseBody is the type of the "nft" service "download"
// endpoint HTTP response body for the "NotFound" error.
type DownloadNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DownloadInternalServerErrorResponseBody is the type of the "nft" service
// "download" endpoint HTTP response body for the "InternalServerError" error.
type DownloadInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ThumbnailcoordinateRequestBody is used to define fields on request body
// types.
type ThumbnailcoordinateRequestBody struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX int64 `form:"top_left_x" json:"top_left_x" xml:"top_left_x"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY int64 `form:"top_left_y" json:"top_left_y" xml:"top_left_y"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX int64 `form:"bottom_right_x" json:"bottom_right_x" xml:"bottom_right_x"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY int64 `form:"bottom_right_y" json:"bottom_right_y" xml:"bottom_right_y"`
}

// TaskStateResponseBody is used to define fields on response body types.
type TaskStateResponseBody struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// NftRegisterPayloadResponseBody is used to define fields on response body
// types.
type NftRegisterPayloadResponseBody struct {
	// Name of the NFT
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Creator's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Passphrase of the artist's PastelID
	CreatorPastelIDPassphrase *string `form:"creator_pastelid_passphrase,omitempty" json:"creator_pastelid_passphrase,omitempty" xml:"creator_pastelid_passphrase,omitempty"`
	// Name of the NFT creator
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// NFT creator website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// Spendable address
	SpendableAddress *string `form:"spendable_address,omitempty" json:"spendable_address,omitempty" xml:"spendable_address,omitempty"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee *float64 `form:"maximum_fee,omitempty" json:"maximum_fee,omitempty" xml:"maximum_fee,omitempty"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                            `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateResponseBody `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
}

// ThumbnailcoordinateResponseBody is used to define fields on response body
// types.
type ThumbnailcoordinateResponseBody struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX *int64 `form:"top_left_x,omitempty" json:"top_left_x,omitempty" xml:"top_left_x,omitempty"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY *int64 `form:"top_left_y,omitempty" json:"top_left_y,omitempty" xml:"top_left_y,omitempty"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX *int64 `form:"bottom_right_x,omitempty" json:"bottom_right_x,omitempty" xml:"bottom_right_x,omitempty"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY *int64 `form:"bottom_right_y,omitempty" json:"bottom_right_y,omitempty" xml:"bottom_right_y,omitempty"`
}

// TaskResponse is used to define fields on response body types.
type TaskResponse struct {
	// JOb ID of the registration process
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of states from the very beginning of the process
	States []*TaskStateResponse `form:"states,omitempty" json:"states,omitempty" xml:"states,omitempty"`
	// txid
	Txid   *string                     `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	Ticket *NftRegisterPayloadResponse `form:"ticket,omitempty" json:"ticket,omitempty" xml:"ticket,omitempty"`
}

// TaskStateResponse is used to define fields on response body types.
type TaskStateResponse struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// NftRegisterPayloadResponse is used to define fields on response body types.
type NftRegisterPayloadResponse struct {
	// Name of the NFT
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Creator's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Passphrase of the artist's PastelID
	CreatorPastelIDPassphrase *string `form:"creator_pastelid_passphrase,omitempty" json:"creator_pastelid_passphrase,omitempty" xml:"creator_pastelid_passphrase,omitempty"`
	// Name of the NFT creator
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// NFT creator website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// Spendable address
	SpendableAddress *string `form:"spendable_address,omitempty" json:"spendable_address,omitempty" xml:"spendable_address,omitempty"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee *float64 `form:"maximum_fee,omitempty" json:"maximum_fee,omitempty" xml:"maximum_fee,omitempty"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                        `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateResponse `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
}

// ThumbnailcoordinateResponse is used to define fields on response body types.
type ThumbnailcoordinateResponse struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX *int64 `form:"top_left_x,omitempty" json:"top_left_x,omitempty" xml:"top_left_x,omitempty"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY *int64 `form:"top_left_y,omitempty" json:"top_left_y,omitempty" xml:"top_left_y,omitempty"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX *int64 `form:"bottom_right_x,omitempty" json:"bottom_right_x,omitempty" xml:"bottom_right_x,omitempty"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY *int64 `form:"bottom_right_y,omitempty" json:"bottom_right_y,omitempty" xml:"bottom_right_y,omitempty"`
}

// NftSummaryResponseBody is used to define fields on response body types.
type NftSummaryResponseBody struct {
	// Thumbnail_1 image
	Thumbnail1 []byte `form:"thumbnail_1,omitempty" json:"thumbnail_1,omitempty" xml:"thumbnail_1,omitempty"`
	// Thumbnail_2 image
	Thumbnail2 []byte `form:"thumbnail_2,omitempty" json:"thumbnail_2,omitempty" xml:"thumbnail_2,omitempty"`
	// txid
	Txid *string `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	// Name of the NFT
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the NFT
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies
	Copies *int `form:"copies,omitempty" json:"copies,omitempty" xml:"copies,omitempty"`
	// NFT creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	CreatorPastelID *string `form:"creator_pastelid,omitempty" json:"creator_pastelid,omitempty" xml:"creator_pastelid,omitempty"`
	// Name of the artist
	CreatorName *string `form:"creator_name,omitempty" json:"creator_name,omitempty" xml:"creator_name,omitempty"`
	// Artist website URL
	CreatorWebsiteURL *string `form:"creator_website_url,omitempty" json:"creator_website_url,omitempty" xml:"creator_website_url,omitempty"`
	// NSFW Average score
	NsfwScore *float32 `form:"nsfw_score,omitempty" json:"nsfw_score,omitempty" xml:"nsfw_score,omitempty"`
	// Average pastel rareness score
	RarenessScore *float32 `form:"rareness_score,omitempty" json:"rareness_score,omitempty" xml:"rareness_score,omitempty"`
	// Is this image likely a duplicate of another known image
	IsLikelyDupe *bool `form:"is_likely_dupe,omitempty" json:"is_likely_dupe,omitempty" xml:"is_likely_dupe,omitempty"`
}

// FuzzyMatchResponseBody is used to define fields on response body types.
type FuzzyMatchResponseBody struct {
	// String that is matched
	Str *string `form:"str,omitempty" json:"str,omitempty" xml:"str,omitempty"`
	// Field that is matched
	FieldType *string `form:"field_type,omitempty" json:"field_type,omitempty" xml:"field_type,omitempty"`
	// The indexes of matched characters. Useful for highlighting matches
	MatchedIndexes []int `form:"matched_indexes,omitempty" json:"matched_indexes,omitempty" xml:"matched_indexes,omitempty"`
	// Score used to rank matches
	Score *int `form:"score,omitempty" json:"score,omitempty" xml:"score,omitempty"`
}

// NewRegisterRequestBody builds the HTTP request body from the payload of the
// "register" endpoint of the "nft" service.
func NewRegisterRequestBody(p *nft.RegisterPayload) *RegisterRequestBody {
	body := &RegisterRequestBody{
		ImageID:                   p.ImageID,
		Name:                      p.Name,
		Description:               p.Description,
		Keywords:                  p.Keywords,
		SeriesName:                p.SeriesName,
		IssuedCopies:              p.IssuedCopies,
		YoutubeURL:                p.YoutubeURL,
		CreatorPastelID:           p.CreatorPastelID,
		CreatorPastelIDPassphrase: p.CreatorPastelIDPassphrase,
		CreatorName:               p.CreatorName,
		CreatorWebsiteURL:         p.CreatorWebsiteURL,
		SpendableAddress:          p.SpendableAddress,
		MaximumFee:                p.MaximumFee,
		Royalty:                   p.Royalty,
		Green:                     p.Green,
	}
	{
		var zero float64
		if body.Royalty == zero {
			body.Royalty = 0
		}
	}
	{
		var zero bool
		if body.Green == zero {
			body.Green = false
		}
	}
	if p.ThumbnailCoordinate != nil {
		body.ThumbnailCoordinate = marshalNftThumbnailcoordinateToThumbnailcoordinateRequestBody(p.ThumbnailCoordinate)
	}
	return body
}

// NewUploadImageRequestBody builds the HTTP request body from the payload of
// the "uploadImage" endpoint of the "nft" service.
func NewUploadImageRequestBody(p *nft.UploadImagePayload) *UploadImageRequestBody {
	body := &UploadImageRequestBody{
		Bytes:    p.Bytes,
		Filename: p.Filename,
	}
	return body
}

// NewNftGetRequestBody builds the HTTP request body from the payload of the
// "nftGet" endpoint of the "nft" service.
func NewNftGetRequestBody(p *nft.NftGetPayload) *NftGetRequestBody {
	body := &NftGetRequestBody{
		UserPastelID:   p.UserPastelID,
		UserPassphrase: p.UserPassphrase,
	}
	return body
}

// NewRegisterResultViewCreated builds a "nft" service "register" endpoint
// result from a HTTP "Created" response.
func NewRegisterResultViewCreated(body *RegisterResponseBody) *nftviews.RegisterResultView {
	v := &nftviews.RegisterResultView{
		TaskID: body.TaskID,
	}

	return v
}

// NewRegisterBadRequest builds a nft service register endpoint BadRequest
// error.
func NewRegisterBadRequest(body *RegisterBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterInternalServerError builds a nft service register endpoint
// InternalServerError error.
func NewRegisterInternalServerError(body *RegisterInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskStateTaskStateOK builds a "nft" service "registerTaskState"
// endpoint result from a HTTP "OK" response.
func NewRegisterTaskStateTaskStateOK(body *RegisterTaskStateResponseBody) *nft.TaskState {
	v := &nft.TaskState{
		Date:   *body.Date,
		Status: *body.Status,
	}

	return v
}

// NewRegisterTaskStateNotFound builds a nft service registerTaskState endpoint
// NotFound error.
func NewRegisterTaskStateNotFound(body *RegisterTaskStateNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskStateInternalServerError builds a nft service
// registerTaskState endpoint InternalServerError error.
func NewRegisterTaskStateInternalServerError(body *RegisterTaskStateInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskTaskOK builds a "nft" service "registerTask" endpoint result
// from a HTTP "OK" response.
func NewRegisterTaskTaskOK(body *RegisterTaskResponseBody) *nftviews.TaskView {
	v := &nftviews.TaskView{
		ID:     body.ID,
		Status: body.Status,
		Txid:   body.Txid,
	}
	if body.States != nil {
		v.States = make([]*nftviews.TaskStateView, len(body.States))
		for i, val := range body.States {
			v.States[i] = unmarshalTaskStateResponseBodyToNftviewsTaskStateView(val)
		}
	}
	v.Ticket = unmarshalNftRegisterPayloadResponseBodyToNftviewsNftRegisterPayloadView(body.Ticket)

	return v
}

// NewRegisterTaskNotFound builds a nft service registerTask endpoint NotFound
// error.
func NewRegisterTaskNotFound(body *RegisterTaskNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskInternalServerError builds a nft service registerTask
// endpoint InternalServerError error.
func NewRegisterTaskInternalServerError(body *RegisterTaskInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTasksTaskCollectionOK builds a "nft" service "registerTasks"
// endpoint result from a HTTP "OK" response.
func NewRegisterTasksTaskCollectionOK(body RegisterTasksResponseBody) nftviews.TaskCollectionView {
	v := make([]*nftviews.TaskView, len(body))
	for i, val := range body {
		v[i] = unmarshalTaskResponseToNftviewsTaskView(val)
	}

	return v
}

// NewRegisterTasksInternalServerError builds a nft service registerTasks
// endpoint InternalServerError error.
func NewRegisterTasksInternalServerError(body *RegisterTasksInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUploadImageImageCreated builds a "nft" service "uploadImage" endpoint
// result from a HTTP "Created" response.
func NewUploadImageImageCreated(body *UploadImageResponseBody) *nftviews.ImageView {
	v := &nftviews.ImageView{
		ImageID:   body.ImageID,
		ExpiresIn: body.ExpiresIn,
	}

	return v
}

// NewUploadImageBadRequest builds a nft service uploadImage endpoint
// BadRequest error.
func NewUploadImageBadRequest(body *UploadImageBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUploadImageInternalServerError builds a nft service uploadImage endpoint
// InternalServerError error.
func NewUploadImageInternalServerError(body *UploadImageInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftSearchResultOK builds a "nft" service "nftSearch" endpoint result from
// a HTTP "OK" response.
func NewNftSearchResultOK(body *NftSearchResponseBody) *nft.NftSearchResult {
	v := &nft.NftSearchResult{
		MatchIndex: *body.MatchIndex,
	}
	v.Nft = unmarshalNftSummaryResponseBodyToNftNftSummary(body.Nft)
	v.Matches = make([]*nft.FuzzyMatch, len(body.Matches))
	for i, val := range body.Matches {
		v.Matches[i] = unmarshalFuzzyMatchResponseBodyToNftFuzzyMatch(val)
	}

	return v
}

// NewNftSearchBadRequest builds a nft service nftSearch endpoint BadRequest
// error.
func NewNftSearchBadRequest(body *NftSearchBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftSearchInternalServerError builds a nft service nftSearch endpoint
// InternalServerError error.
func NewNftSearchInternalServerError(body *NftSearchInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftGetNftDetailOK builds a "nft" service "nftGet" endpoint result from a
// HTTP "OK" response.
func NewNftGetNftDetailOK(body *NftGetResponseBody) *nft.NftDetail {
	v := &nft.NftDetail{
		Version:                 body.Version,
		GreenAddress:            body.GreenAddress,
		Royalty:                 body.Royalty,
		StorageFee:              body.StorageFee,
		NsfwScore:               *body.NsfwScore,
		RarenessScore:           *body.RarenessScore,
		IsLikelyDupe:            body.IsLikelyDupe,
		MatchesFoundOnFirstPage: body.MatchesFoundOnFirstPage,
		NumberOfPagesOfResults:  body.NumberOfPagesOfResults,
		URLOfFirstMatchInPage:   body.URLOfFirstMatchInPage,
		DrawingNsfwScore:        body.DrawingNsfwScore,
		NeutralNsfwScore:        body.NeutralNsfwScore,
		SexyNsfwScore:           body.SexyNsfwScore,
		PornNsfwScore:           body.PornNsfwScore,
		HentaiNsfwScore:         body.HentaiNsfwScore,
		PreviewThumbnail:        body.PreviewThumbnail,
		Thumbnail1:              body.Thumbnail1,
		Thumbnail2:              body.Thumbnail2,
		Txid:                    *body.Txid,
		Title:                   *body.Title,
		Description:             *body.Description,
		Keywords:                body.Keywords,
		SeriesName:              body.SeriesName,
		Copies:                  *body.Copies,
		YoutubeURL:              body.YoutubeURL,
		CreatorPastelID:         *body.CreatorPastelID,
		CreatorName:             *body.CreatorName,
		CreatorWebsiteURL:       body.CreatorWebsiteURL,
	}

	return v
}

// NewNftGetBadRequest builds a nft service nftGet endpoint BadRequest error.
func NewNftGetBadRequest(body *NftGetBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftGetNotFound builds a nft service nftGet endpoint NotFound error.
func NewNftGetNotFound(body *NftGetNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewNftGetInternalServerError builds a nft service nftGet endpoint
// InternalServerError error.
func NewNftGetInternalServerError(body *NftGetInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDownloadResultOK builds a "nft" service "download" endpoint result from a
// HTTP "OK" response.
func NewDownloadResultOK(body *DownloadResponseBody) *nft.DownloadResult {
	v := &nft.DownloadResult{
		File: body.File,
	}

	return v
}

// NewDownloadNotFound builds a nft service download endpoint NotFound error.
func NewDownloadNotFound(body *DownloadNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDownloadInternalServerError builds a nft service download endpoint
// InternalServerError error.
func NewDownloadInternalServerError(body *DownloadInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// ValidateRegisterTaskStateResponseBody runs the validations defined on
// RegisterTaskStateResponseBody
func ValidateRegisterTaskStateResponseBody(body *RegisterTaskStateResponseBody) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateNftSearchResponseBody runs the validations defined on
// NftSearchResponseBody
func ValidateNftSearchResponseBody(body *NftSearchResponseBody) (err error) {
	if body.Nft == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nft", "body"))
	}
	if body.Matches == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("matches", "body"))
	}
	if body.MatchIndex == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("match_index", "body"))
	}
	if body.Nft != nil {
		if err2 := ValidateNftSummaryResponseBody(body.Nft); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Matches {
		if e != nil {
			if err2 := ValidateFuzzyMatchResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateNftGetResponseBody runs the validations defined on NftGetResponseBody
func ValidateNftGetResponseBody(body *NftGetResponseBody) (err error) {
	if body.RarenessScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("rareness_score", "body"))
	}
	if body.NsfwScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nsfw_score", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Copies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("copies", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.Txid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txid", "body"))
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 0, true))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 1, false))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 0, true))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 1, false))
		}
	}
	if body.MatchesFoundOnFirstPage != nil {
		if *body.MatchesFoundOnFirstPage < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.matches_found_on_first_page", *body.MatchesFoundOnFirstPage, 0, true))
		}
	}
	if body.NumberOfPagesOfResults != nil {
		if *body.NumberOfPagesOfResults < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.number_of_pages_of_results", *body.NumberOfPagesOfResults, 0, true))
		}
	}
	if body.DrawingNsfwScore != nil {
		if *body.DrawingNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.drawing_nsfw_score", *body.DrawingNsfwScore, 0, true))
		}
	}
	if body.DrawingNsfwScore != nil {
		if *body.DrawingNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.drawing_nsfw_score", *body.DrawingNsfwScore, 1, false))
		}
	}
	if body.NeutralNsfwScore != nil {
		if *body.NeutralNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.neutral_nsfw_score", *body.NeutralNsfwScore, 0, true))
		}
	}
	if body.NeutralNsfwScore != nil {
		if *body.NeutralNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.neutral_nsfw_score", *body.NeutralNsfwScore, 1, false))
		}
	}
	if body.SexyNsfwScore != nil {
		if *body.SexyNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.sexy_nsfw_score", *body.SexyNsfwScore, 0, true))
		}
	}
	if body.SexyNsfwScore != nil {
		if *body.SexyNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.sexy_nsfw_score", *body.SexyNsfwScore, 1, false))
		}
	}
	if body.PornNsfwScore != nil {
		if *body.PornNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.porn_nsfw_score", *body.PornNsfwScore, 0, true))
		}
	}
	if body.PornNsfwScore != nil {
		if *body.PornNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.porn_nsfw_score", *body.PornNsfwScore, 1, false))
		}
	}
	if body.HentaiNsfwScore != nil {
		if *body.HentaiNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hentai_nsfw_score", *body.HentaiNsfwScore, 0, true))
		}
	}
	if body.HentaiNsfwScore != nil {
		if *body.HentaiNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hentai_nsfw_score", *body.HentaiNsfwScore, 1, false))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.Copies != nil {
		if *body.Copies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1, true))
		}
	}
	if body.Copies != nil {
		if *body.Copies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	return
}

// ValidateDownloadResponseBody runs the validations defined on
// DownloadResponseBody
func ValidateDownloadResponseBody(body *DownloadResponseBody) (err error) {
	if body.File == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("file", "body"))
	}
	return
}

// ValidateRegisterBadRequestResponseBody runs the validations defined on
// register_BadRequest_response_body
func ValidateRegisterBadRequestResponseBody(body *RegisterBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterInternalServerErrorResponseBody runs the validations defined
// on register_InternalServerError_response_body
func ValidateRegisterInternalServerErrorResponseBody(body *RegisterInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskStateNotFoundResponseBody runs the validations defined
// on registerTaskState_NotFound_response_body
func ValidateRegisterTaskStateNotFoundResponseBody(body *RegisterTaskStateNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskStateInternalServerErrorResponseBody runs the
// validations defined on registerTaskState_InternalServerError_response_body
func ValidateRegisterTaskStateInternalServerErrorResponseBody(body *RegisterTaskStateInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskNotFoundResponseBody runs the validations defined on
// registerTask_NotFound_response_body
func ValidateRegisterTaskNotFoundResponseBody(body *RegisterTaskNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskInternalServerErrorResponseBody runs the validations
// defined on registerTask_InternalServerError_response_body
func ValidateRegisterTaskInternalServerErrorResponseBody(body *RegisterTaskInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTasksInternalServerErrorResponseBody runs the validations
// defined on registerTasks_InternalServerError_response_body
func ValidateRegisterTasksInternalServerErrorResponseBody(body *RegisterTasksInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUploadImageBadRequestResponseBody runs the validations defined on
// uploadImage_BadRequest_response_body
func ValidateUploadImageBadRequestResponseBody(body *UploadImageBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUploadImageInternalServerErrorResponseBody runs the validations
// defined on uploadImage_InternalServerError_response_body
func ValidateUploadImageInternalServerErrorResponseBody(body *UploadImageInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftSearchBadRequestResponseBody runs the validations defined on
// nftSearch_BadRequest_response_body
func ValidateNftSearchBadRequestResponseBody(body *NftSearchBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftSearchInternalServerErrorResponseBody runs the validations
// defined on nftSearch_InternalServerError_response_body
func ValidateNftSearchInternalServerErrorResponseBody(body *NftSearchInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftGetBadRequestResponseBody runs the validations defined on
// nftGet_BadRequest_response_body
func ValidateNftGetBadRequestResponseBody(body *NftGetBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftGetNotFoundResponseBody runs the validations defined on
// nftGet_NotFound_response_body
func ValidateNftGetNotFoundResponseBody(body *NftGetNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateNftGetInternalServerErrorResponseBody runs the validations defined
// on nftGet_InternalServerError_response_body
func ValidateNftGetInternalServerErrorResponseBody(body *NftGetInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDownloadNotFoundResponseBody runs the validations defined on
// download_NotFound_response_body
func ValidateDownloadNotFoundResponseBody(body *DownloadNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDownloadInternalServerErrorResponseBody runs the validations defined
// on download_InternalServerError_response_body
func ValidateDownloadInternalServerErrorResponseBody(body *DownloadInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateTaskStateResponseBody runs the validations defined on
// TaskStateResponseBody
func ValidateTaskStateResponseBody(body *TaskStateResponseBody) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateNftRegisterPayloadResponseBody runs the validations defined on
// NftRegisterPayloadResponseBody
func ValidateNftRegisterPayloadResponseBody(body *NftRegisterPayloadResponseBody) (err error) {
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.IssuedCopies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("issued_copies", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.CreatorPastelIDPassphrase == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid_passphrase", "body"))
	}
	if body.SpendableAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spendable_address", "body"))
	}
	if body.MaximumFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("maximum_fee", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1, true))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	if body.SpendableAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spendable_address", *body.SpendableAddress, "^[a-zA-Z0-9]+$"))
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) < 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, true))
		}
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) > 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, false))
		}
	}
	if body.MaximumFee != nil {
		if *body.MaximumFee < 1e-05 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.maximum_fee", *body.MaximumFee, 1e-05, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 0, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 100, false))
		}
	}
	if body.ThumbnailCoordinate != nil {
		if err2 := ValidateThumbnailcoordinateResponseBody(body.ThumbnailCoordinate); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateThumbnailcoordinateResponseBody runs the validations defined on
// ThumbnailcoordinateResponseBody
func ValidateThumbnailcoordinateResponseBody(body *ThumbnailcoordinateResponseBody) (err error) {
	if body.TopLeftX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_x", "body"))
	}
	if body.TopLeftY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_y", "body"))
	}
	if body.BottomRightX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_x", "body"))
	}
	if body.BottomRightY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_y", "body"))
	}
	return
}

// ValidateTaskResponse runs the validations defined on TaskResponse
func ValidateTaskResponse(body *TaskResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Ticket == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ticket", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 8, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 8, false))
		}
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	for _, e := range body.States {
		if e != nil {
			if err2 := ValidateTaskStateResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Ticket != nil {
		if err2 := ValidateNftRegisterPayloadResponse(body.Ticket); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateTaskStateResponse runs the validations defined on TaskStateResponse
func ValidateTaskStateResponse(body *TaskStateResponse) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Downloaded" || *body.Status == "Request Accepted" || *body.Status == "Request Registered" || *body.Status == "Request Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Signatures Dont Match" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Error File Don't Match" || *body.Status == "Error Not Enough SuperNode" || *body.Status == "Error Find Responding SNs" || *body.Status == "Error Not Enough Downloaded Filed" || *body.Status == "Error Download Failed" || *body.Status == "Error Invalid Burn TxID" || *body.Status == "Task Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Downloaded", "Request Accepted", "Request Registered", "Request Activated", "Error Insufficient Fee", "Error Signatures Dont Match", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Error File Don't Match", "Error Not Enough SuperNode", "Error Find Responding SNs", "Error Not Enough Downloaded Filed", "Error Download Failed", "Error Invalid Burn TxID", "Task Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateNftRegisterPayloadResponse runs the validations defined on
// NftRegisterPayloadResponse
func ValidateNftRegisterPayloadResponse(body *NftRegisterPayloadResponse) (err error) {
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.IssuedCopies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("issued_copies", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.CreatorPastelIDPassphrase == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid_passphrase", "body"))
	}
	if body.SpendableAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spendable_address", "body"))
	}
	if body.MaximumFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("maximum_fee", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1, true))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	if body.SpendableAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spendable_address", *body.SpendableAddress, "^[a-zA-Z0-9]+$"))
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) < 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, true))
		}
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) > 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, false))
		}
	}
	if body.MaximumFee != nil {
		if *body.MaximumFee < 1e-05 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.maximum_fee", *body.MaximumFee, 1e-05, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 0, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 100, false))
		}
	}
	if body.ThumbnailCoordinate != nil {
		if err2 := ValidateThumbnailcoordinateResponse(body.ThumbnailCoordinate); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateThumbnailcoordinateResponse runs the validations defined on
// ThumbnailcoordinateResponse
func ValidateThumbnailcoordinateResponse(body *ThumbnailcoordinateResponse) (err error) {
	if body.TopLeftX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_x", "body"))
	}
	if body.TopLeftY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_y", "body"))
	}
	if body.BottomRightX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_x", "body"))
	}
	if body.BottomRightY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_y", "body"))
	}
	return
}

// ValidateNftSummaryResponseBody runs the validations defined on
// NftSummaryResponseBody
func ValidateNftSummaryResponseBody(body *NftSummaryResponseBody) (err error) {
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.CreatorName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_name", "body"))
	}
	if body.Copies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("copies", "body"))
	}
	if body.CreatorPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("creator_pastelid", "body"))
	}
	if body.Txid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txid", "body"))
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.Copies != nil {
		if *body.Copies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1, true))
		}
	}
	if body.Copies != nil {
		if *body.Copies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.CreatorPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.creator_pastelid", *body.CreatorPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, true))
		}
	}
	if body.CreatorPastelID != nil {
		if utf8.RuneCountInString(*body.CreatorPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_pastelid", *body.CreatorPastelID, utf8.RuneCountInString(*body.CreatorPastelID), 86, false))
		}
	}
	if body.CreatorName != nil {
		if utf8.RuneCountInString(*body.CreatorName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_name", *body.CreatorName, utf8.RuneCountInString(*body.CreatorName), 256, false))
		}
	}
	if body.CreatorWebsiteURL != nil {
		if utf8.RuneCountInString(*body.CreatorWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.creator_website_url", *body.CreatorWebsiteURL, utf8.RuneCountInString(*body.CreatorWebsiteURL), 256, false))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 0, true))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 1, false))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 0, true))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 1, false))
		}
	}
	return
}

// ValidateFuzzyMatchResponseBody runs the validations defined on
// FuzzyMatchResponseBody
func ValidateFuzzyMatchResponseBody(body *FuzzyMatchResponseBody) (err error) {
	if body.FieldType != nil {
		if !(*body.FieldType == "creator_name" || *body.FieldType == "art_title" || *body.FieldType == "series" || *body.FieldType == "descr" || *body.FieldType == "keyword") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.field_type", *body.FieldType, []interface{}{"creator_name", "art_title", "series", "descr", "keyword"}))
		}
	}
	return
}

// Code generated by goa v3.15.0, DO NOT EDIT.
//
// cascade HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/pastelnetwork/gonode/walletnode/api/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strings"
	"unicode/utf8"

	cascade "github.com/pastelnetwork/gonode/walletnode/api/gen/cascade"
	cascadeviews "github.com/pastelnetwork/gonode/walletnode/api/gen/cascade/views"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeUploadAssetResponse returns an encoder for responses returned by the
// cascade uploadAsset endpoint.
func EncodeUploadAssetResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*cascadeviews.Asset)
		enc := encoder(ctx, w)
		body := NewUploadAssetResponseBody(res.Projected)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeUploadAssetRequest returns a decoder for requests sent to the cascade
// uploadAsset endpoint.
func DecodeUploadAssetRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var payload *cascade.UploadAssetPayload
		if err := decoder(r).Decode(&payload); err != nil {
			return nil, goa.DecodePayloadError(err.Error())
		}

		return payload, nil
	}
}

// NewCascadeUploadAssetDecoder returns a decoder to decode the multipart
// request for the "cascade" service "uploadAsset" endpoint.
func NewCascadeUploadAssetDecoder(mux goahttp.Muxer, cascadeUploadAssetDecoderFn CascadeUploadAssetDecoderFunc) func(r *http.Request) goahttp.Decoder {
	return func(r *http.Request) goahttp.Decoder {
		return goahttp.EncodingFunc(func(v any) error {
			mr, merr := r.MultipartReader()
			if merr != nil {
				return merr
			}
			p := v.(**cascade.UploadAssetPayload)
			if err := cascadeUploadAssetDecoderFn(mr, p); err != nil {
				return err
			}
			return nil
		})
	}
}

// EncodeUploadAssetError returns an encoder for errors returned by the
// uploadAsset cascade endpoint.
func EncodeUploadAssetError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUploadAssetBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUploadAssetInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUploadAssetV2Response returns an encoder for responses returned by the
// cascade uploadAssetV2 endpoint.
func EncodeUploadAssetV2Response(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*cascadeviews.AssetV2)
		enc := encoder(ctx, w)
		body := NewUploadAssetV2ResponseBody(res.Projected)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeUploadAssetV2Request returns a decoder for requests sent to the
// cascade uploadAssetV2 endpoint.
func DecodeUploadAssetV2Request(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var payload *cascade.UploadAssetV2Payload
		if err := decoder(r).Decode(&payload); err != nil {
			return nil, goa.DecodePayloadError(err.Error())
		}

		return payload, nil
	}
}

// NewCascadeUploadAssetV2Decoder returns a decoder to decode the multipart
// request for the "cascade" service "uploadAssetV2" endpoint.
func NewCascadeUploadAssetV2Decoder(mux goahttp.Muxer, cascadeUploadAssetV2DecoderFn CascadeUploadAssetV2DecoderFunc) func(r *http.Request) goahttp.Decoder {
	return func(r *http.Request) goahttp.Decoder {
		return goahttp.EncodingFunc(func(v any) error {
			mr, merr := r.MultipartReader()
			if merr != nil {
				return merr
			}
			p := v.(**cascade.UploadAssetV2Payload)
			if err := cascadeUploadAssetV2DecoderFn(mr, p); err != nil {
				return err
			}
			return nil
		})
	}
}

// EncodeUploadAssetV2Error returns an encoder for errors returned by the
// uploadAssetV2 cascade endpoint.
func EncodeUploadAssetV2Error(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUploadAssetV2BadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUploadAssetV2InternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeStartProcessingResponse returns an encoder for responses returned by
// the cascade startProcessing endpoint.
func EncodeStartProcessingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*cascadeviews.StartProcessingResult)
		enc := encoder(ctx, w)
		body := NewStartProcessingResponseBody(res.Projected)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeStartProcessingRequest returns a decoder for requests sent to the
// cascade startProcessing endpoint.
func DecodeStartProcessingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body StartProcessingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateStartProcessingRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			fileID string
			key    string

			params = mux.Vars(r)
		)
		fileID = params["file_id"]
		if utf8.RuneCountInString(fileID) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("file_id", fileID, utf8.RuneCountInString(fileID), 8, true))
		}
		if utf8.RuneCountInString(fileID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("file_id", fileID, utf8.RuneCountInString(fileID), 8, false))
		}
		key = r.Header.Get("Authorization")
		if key == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("key", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewStartProcessingPayload(&body, fileID, key)
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}

		return payload, nil
	}
}

// EncodeStartProcessingError returns an encoder for errors returned by the
// startProcessing cascade endpoint.
func EncodeStartProcessingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "UnAuthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartProcessingUnAuthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "BadRequest":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartProcessingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewStartProcessingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// DecodeRegisterTaskStateRequest returns a decoder for requests sent to the
// cascade registerTaskState endpoint.
func DecodeRegisterTaskStateRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			taskID string
			err    error

			params = mux.Vars(r)
		)
		taskID = params["taskId"]
		if utf8.RuneCountInString(taskID) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("taskId", taskID, utf8.RuneCountInString(taskID), 8, true))
		}
		if utf8.RuneCountInString(taskID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("taskId", taskID, utf8.RuneCountInString(taskID), 8, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRegisterTaskStatePayload(taskID)

		return payload, nil
	}
}

// EncodeRegisterTaskStateError returns an encoder for errors returned by the
// registerTaskState cascade endpoint.
func EncodeRegisterTaskStateError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "NotFound":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterTaskStateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterTaskStateInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetTaskHistoryResponse returns an encoder for responses returned by
// the cascade getTaskHistory endpoint.
func EncodeGetTaskHistoryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]*cascade.TaskHistory)
		enc := encoder(ctx, w)
		body := NewGetTaskHistoryResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetTaskHistoryRequest returns a decoder for requests sent to the
// cascade getTaskHistory endpoint.
func DecodeGetTaskHistoryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			taskID string
			err    error

			params = mux.Vars(r)
		)
		taskID = params["taskId"]
		if utf8.RuneCountInString(taskID) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("taskId", taskID, utf8.RuneCountInString(taskID), 8, true))
		}
		if utf8.RuneCountInString(taskID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("taskId", taskID, utf8.RuneCountInString(taskID), 8, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetTaskHistoryPayload(taskID)

		return payload, nil
	}
}

// EncodeGetTaskHistoryError returns an encoder for errors returned by the
// getTaskHistory cascade endpoint.
func EncodeGetTaskHistoryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "NotFound":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetTaskHistoryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetTaskHistoryInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDownloadResponse returns an encoder for responses returned by the
// cascade download endpoint.
func EncodeDownloadResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*cascade.FileDownloadResult)
		enc := encoder(ctx, w)
		body := NewDownloadResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDownloadRequest returns a decoder for requests sent to the cascade
// download endpoint.
func DecodeDownloadRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			txid string
			pid  string
			key  string
			err  error
		)
		txid = r.URL.Query().Get("txid")
		if txid == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("txid", "query string"))
		}
		if utf8.RuneCountInString(txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("txid", txid, utf8.RuneCountInString(txid), 64, true))
		}
		if utf8.RuneCountInString(txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("txid", txid, utf8.RuneCountInString(txid), 64, false))
		}
		pid = r.URL.Query().Get("pid")
		if pid == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("pid", "query string"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("pid", pid, "^[a-zA-Z0-9]+$"))
		if utf8.RuneCountInString(pid) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("pid", pid, utf8.RuneCountInString(pid), 86, true))
		}
		if utf8.RuneCountInString(pid) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("pid", pid, utf8.RuneCountInString(pid), 86, false))
		}
		key = r.Header.Get("Authorization")
		if key == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("key", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDownloadPayload(txid, pid, key)
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}

		return payload, nil
	}
}

// EncodeDownloadError returns an encoder for errors returned by the download
// cascade endpoint.
func EncodeDownloadError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "UnAuthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDownloadUnAuthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "NotFound":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDownloadNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDownloadInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDownloadV2Response returns an encoder for responses returned by the
// cascade downloadV2 endpoint.
func EncodeDownloadV2Response(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*cascade.FileDownloadV2Result)
		enc := encoder(ctx, w)
		body := NewDownloadV2ResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeDownloadV2Request returns a decoder for requests sent to the cascade
// downloadV2 endpoint.
func DecodeDownloadV2Request(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			txid string
			pid  string
			key  string
			err  error
		)
		txid = r.URL.Query().Get("txid")
		if txid == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("txid", "query string"))
		}
		if utf8.RuneCountInString(txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("txid", txid, utf8.RuneCountInString(txid), 64, true))
		}
		if utf8.RuneCountInString(txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("txid", txid, utf8.RuneCountInString(txid), 64, false))
		}
		pid = r.URL.Query().Get("pid")
		if pid == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("pid", "query string"))
		}
		err = goa.MergeErrors(err, goa.ValidatePattern("pid", pid, "^[a-zA-Z0-9]+$"))
		if utf8.RuneCountInString(pid) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("pid", pid, utf8.RuneCountInString(pid), 86, true))
		}
		if utf8.RuneCountInString(pid) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("pid", pid, utf8.RuneCountInString(pid), 86, false))
		}
		key = r.Header.Get("Authorization")
		if key == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("key", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewDownloadV2DownloadPayload(txid, pid, key)
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}

		return payload, nil
	}
}

// EncodeDownloadV2Error returns an encoder for errors returned by the
// downloadV2 cascade endpoint.
func EncodeDownloadV2Error(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "UnAuthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDownloadV2UnAuthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "NotFound":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDownloadV2NotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDownloadV2InternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetDownloadTaskStateResponse returns an encoder for responses returned
// by the cascade getDownloadTaskState endpoint.
func EncodeGetDownloadTaskStateResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*cascade.DownloadTaskStatus)
		enc := encoder(ctx, w)
		body := NewGetDownloadTaskStateResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetDownloadTaskStateRequest returns a decoder for requests sent to the
// cascade getDownloadTaskState endpoint.
func DecodeGetDownloadTaskStateRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			fileID string
			err    error

			params = mux.Vars(r)
		)
		fileID = params["file_id"]
		if utf8.RuneCountInString(fileID) < 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("file_id", fileID, utf8.RuneCountInString(fileID), 6, true))
		}
		if utf8.RuneCountInString(fileID) > 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("file_id", fileID, utf8.RuneCountInString(fileID), 6, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetDownloadTaskStatePayload(fileID)

		return payload, nil
	}
}

// EncodeGetDownloadTaskStateError returns an encoder for errors returned by
// the getDownloadTaskState cascade endpoint.
func EncodeGetDownloadTaskStateError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "NotFound":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDownloadTaskStateNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetDownloadTaskStateInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRegistrationDetailsResponse returns an encoder for responses returned
// by the cascade registrationDetails endpoint.
func EncodeRegistrationDetailsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*cascadeviews.Registration)
		enc := encoder(ctx, w)
		body := NewRegistrationDetailsResponseBody(res.Projected)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeRegistrationDetailsRequest returns a decoder for requests sent to the
// cascade registrationDetails endpoint.
func DecodeRegistrationDetailsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			baseFileID string
			err        error

			params = mux.Vars(r)
		)
		baseFileID = params["base_file_id"]
		if utf8.RuneCountInString(baseFileID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("base_file_id", baseFileID, utf8.RuneCountInString(baseFileID), 8, false))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRegistrationDetailsPayload(baseFileID)

		return payload, nil
	}
}

// EncodeRegistrationDetailsError returns an encoder for errors returned by the
// registrationDetails cascade endpoint.
func EncodeRegistrationDetailsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "UnAuthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegistrationDetailsUnAuthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "BadRequest":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegistrationDetailsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegistrationDetailsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRestoreResponse returns an encoder for responses returned by the
// cascade restore endpoint.
func EncodeRestoreResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res := v.(*cascadeviews.RestoreFile)
		enc := encoder(ctx, w)
		body := NewRestoreResponseBody(res.Projected)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeRestoreRequest returns a decoder for requests sent to the cascade
// restore endpoint.
func DecodeRestoreRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body RestoreRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateRestoreRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			baseFileID string
			key        string

			params = mux.Vars(r)
		)
		baseFileID = params["base_file_id"]
		if utf8.RuneCountInString(baseFileID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("base_file_id", baseFileID, utf8.RuneCountInString(baseFileID), 8, false))
		}
		key = r.Header.Get("Authorization")
		if key == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("key", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewRestorePayload(&body, baseFileID, key)
		if strings.Contains(payload.Key, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.Key, " ", 2)[1]
			payload.Key = cred
		}

		return payload, nil
	}
}

// EncodeRestoreError returns an encoder for errors returned by the restore
// cascade endpoint.
func EncodeRestoreError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "UnAuthorized":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreUnAuthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		case "BadRequest":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *goa.ServiceError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRestoreInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalCascadeTaskHistoryToTaskHistoryResponse builds a value of type
// *TaskHistoryResponse from a value of type *cascade.TaskHistory.
func marshalCascadeTaskHistoryToTaskHistoryResponse(v *cascade.TaskHistory) *TaskHistoryResponse {
	res := &TaskHistoryResponse{
		Timestamp: v.Timestamp,
		Status:    v.Status,
		Message:   v.Message,
	}
	if v.Details != nil {
		res.Details = marshalCascadeDetailsToDetailsResponse(v.Details)
	}

	return res
}

// marshalCascadeDetailsToDetailsResponse builds a value of type
// *DetailsResponse from a value of type *cascade.Details.
func marshalCascadeDetailsToDetailsResponse(v *cascade.Details) *DetailsResponse {
	if v == nil {
		return nil
	}
	res := &DetailsResponse{
		Message: v.Message,
	}
	if v.Fields != nil {
		res.Fields = make(map[string]any, len(v.Fields))
		for key, val := range v.Fields {
			tk := key
			tv := val
			res.Fields[tk] = tv
		}
	}

	return res
}

// marshalCascadeDetailsToDetailsResponseBody builds a value of type
// *DetailsResponseBody from a value of type *cascade.Details.
func marshalCascadeDetailsToDetailsResponseBody(v *cascade.Details) *DetailsResponseBody {
	res := &DetailsResponseBody{
		Message: v.Message,
	}
	if v.Fields != nil {
		res.Fields = make(map[string]any, len(v.Fields))
		for key, val := range v.Fields {
			tk := key
			tv := val
			res.Fields[tk] = tv
		}
	}

	return res
}

// marshalCascadeviewsFileViewToFileResponseBody builds a value of type
// *FileResponseBody from a value of type *cascadeviews.FileView.
func marshalCascadeviewsFileViewToFileResponseBody(v *cascadeviews.FileView) *FileResponseBody {
	res := &FileResponseBody{
		FileID:                       *v.FileID,
		UploadTimestamp:              *v.UploadTimestamp,
		FileIndex:                    v.FileIndex,
		BaseFileID:                   *v.BaseFileID,
		TaskID:                       *v.TaskID,
		RegTxid:                      v.RegTxid,
		ActivationTxid:               v.ActivationTxid,
		ReqBurnTxnAmount:             *v.ReqBurnTxnAmount,
		BurnTxnID:                    v.BurnTxnID,
		ReqAmount:                    *v.ReqAmount,
		IsConcluded:                  v.IsConcluded,
		CascadeMetadataTicketID:      *v.CascadeMetadataTicketID,
		UUIDKey:                      v.UUIDKey,
		HashOfOriginalBigFile:        *v.HashOfOriginalBigFile,
		NameOfOriginalBigFileWithExt: *v.NameOfOriginalBigFileWithExt,
		SizeOfOriginalBigFile:        *v.SizeOfOriginalBigFile,
		StartBlock:                   v.StartBlock,
		DoneBlock:                    v.DoneBlock,
	}
	if v.RegistrationAttempts != nil {
		res.RegistrationAttempts = make([]*RegistrationAttemptResponseBody, len(v.RegistrationAttempts))
		for i, val := range v.RegistrationAttempts {
			res.RegistrationAttempts[i] = marshalCascadeviewsRegistrationAttemptViewToRegistrationAttemptResponseBody(val)
		}
	} else {
		res.RegistrationAttempts = []*RegistrationAttemptResponseBody{}
	}
	if v.ActivationAttempts != nil {
		res.ActivationAttempts = make([]*ActivationAttemptResponseBody, len(v.ActivationAttempts))
		for i, val := range v.ActivationAttempts {
			res.ActivationAttempts[i] = marshalCascadeviewsActivationAttemptViewToActivationAttemptResponseBody(val)
		}
	} else {
		res.ActivationAttempts = []*ActivationAttemptResponseBody{}
	}

	return res
}

// marshalCascadeviewsRegistrationAttemptViewToRegistrationAttemptResponseBody
// builds a value of type *RegistrationAttemptResponseBody from a value of type
// *cascadeviews.RegistrationAttemptView.
func marshalCascadeviewsRegistrationAttemptViewToRegistrationAttemptResponseBody(v *cascadeviews.RegistrationAttemptView) *RegistrationAttemptResponseBody {
	res := &RegistrationAttemptResponseBody{
		ID:           *v.ID,
		FileID:       *v.FileID,
		RegStartedAt: *v.RegStartedAt,
		ProcessorSns: v.ProcessorSns,
		FinishedAt:   *v.FinishedAt,
		IsSuccessful: v.IsSuccessful,
		IsConfirmed:  v.IsConfirmed,
		ErrorMessage: v.ErrorMessage,
	}

	return res
}

// marshalCascadeviewsActivationAttemptViewToActivationAttemptResponseBody
// builds a value of type *ActivationAttemptResponseBody from a value of type
// *cascadeviews.ActivationAttemptView.
func marshalCascadeviewsActivationAttemptViewToActivationAttemptResponseBody(v *cascadeviews.ActivationAttemptView) *ActivationAttemptResponseBody {
	res := &ActivationAttemptResponseBody{
		ID:                  *v.ID,
		FileID:              *v.FileID,
		ActivationAttemptAt: *v.ActivationAttemptAt,
		IsSuccessful:        v.IsSuccessful,
		IsConfirmed:         v.IsConfirmed,
		ErrorMessage:        v.ErrorMessage,
	}

	return res
}

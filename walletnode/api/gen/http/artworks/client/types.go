// Code generated by goa v3.4.3, DO NOT EDIT.
//
// artworks HTTP client types
//
// Command:
// $ goa gen github.com/pastelnetwork/gonode/walletnode/api/design

package client

import (
	"unicode/utf8"

	artworks "github.com/pastelnetwork/gonode/walletnode/api/gen/artworks"
	artworksviews "github.com/pastelnetwork/gonode/walletnode/api/gen/artworks/views"
	goa "goa.design/goa/v3/pkg"
)

// RegisterRequestBody is the type of the "artworks" service "register"
// endpoint HTTP request body.
type RegisterRequestBody struct {
	// Uploaded image ID
	ImageID string `form:"image_id" json:"image_id" xml:"image_id"`
	// Name of the artwork
	Name string `form:"name" json:"name" xml:"name"`
	// Description of the artwork
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies int `form:"issued_copies" json:"issued_copies" xml:"issued_copies"`
	// Artwork creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	ArtistPastelID string `form:"artist_pastelid" json:"artist_pastelid" xml:"artist_pastelid"`
	// Passphrase of the artist's PastelID
	ArtistPastelIDPassphrase string `form:"artist_pastelid_passphrase" json:"artist_pastelid_passphrase" xml:"artist_pastelid_passphrase"`
	// Name of the artist
	ArtistName string `form:"artist_name" json:"artist_name" xml:"artist_name"`
	// Artist website URL
	ArtistWebsiteURL *string `form:"artist_website_url,omitempty" json:"artist_website_url,omitempty" xml:"artist_website_url,omitempty"`
	// Spendable address
	SpendableAddress string `form:"spendable_address" json:"spendable_address" xml:"spendable_address"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee float64 `form:"maximum_fee" json:"maximum_fee" xml:"maximum_fee"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty float64 `form:"royalty" json:"royalty" xml:"royalty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               bool                            `form:"green" json:"green" xml:"green"`
	ThumbnailCoordinate *ThumbnailcoordinateRequestBody `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
}

// UploadImageRequestBody is the type of the "artworks" service "uploadImage"
// endpoint HTTP request body.
type UploadImageRequestBody struct {
	// File to upload
	Bytes []byte `form:"file" json:"file" xml:"file"`
	// For internal use
	Filename *string `form:"filename,omitempty" json:"filename,omitempty" xml:"filename,omitempty"`
}

// RegisterResponseBody is the type of the "artworks" service "register"
// endpoint HTTP response body.
type RegisterResponseBody struct {
	// Task ID of the registration process
	TaskID *string `form:"task_id,omitempty" json:"task_id,omitempty" xml:"task_id,omitempty"`
}

// RegisterTaskStateResponseBody is the type of the "artworks" service
// "registerTaskState" endpoint HTTP response body.
type RegisterTaskStateResponseBody struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// RegisterTaskResponseBody is the type of the "artworks" service
// "registerTask" endpoint HTTP response body.
type RegisterTaskResponseBody struct {
	// JOb ID of the registration process
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of states from the very beginning of the process
	States []*TaskStateResponseBody `form:"states,omitempty" json:"states,omitempty" xml:"states,omitempty"`
	// txid
	Txid   *string                    `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	Ticket *ArtworkTicketResponseBody `form:"ticket,omitempty" json:"ticket,omitempty" xml:"ticket,omitempty"`
}

// RegisterTasksResponseBody is the type of the "artworks" service
// "registerTasks" endpoint HTTP response body.
type RegisterTasksResponseBody []*TaskResponse

// UploadImageResponseBody is the type of the "artworks" service "uploadImage"
// endpoint HTTP response body.
type UploadImageResponseBody struct {
	// Uploaded image ID
	ImageID *string `form:"image_id,omitempty" json:"image_id,omitempty" xml:"image_id,omitempty"`
	// Image expiration
	ExpiresIn *string `form:"expires_in,omitempty" json:"expires_in,omitempty" xml:"expires_in,omitempty"`
}

// ArtSearchResponseBody is the type of the "artworks" service "artSearch"
// endpoint HTTP response body.
type ArtSearchResponseBody struct {
	// Artwork data
	Artwork *ArtworkSummaryResponseBody `form:"artwork,omitempty" json:"artwork,omitempty" xml:"artwork,omitempty"`
	// Sort index of the match based on score.This must be used to sort results on
	// UI.
	MatchIndex *int `form:"match_index,omitempty" json:"match_index,omitempty" xml:"match_index,omitempty"`
	// Match result details
	Matches []*FuzzyMatchResponseBody `form:"matches,omitempty" json:"matches,omitempty" xml:"matches,omitempty"`
}

// ArtworkGetResponseBody is the type of the "artworks" service "artworkGet"
// endpoint HTTP response body.
type ArtworkGetResponseBody struct {
	// version
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
	// Green address
	GreenAddress *bool `form:"green_address,omitempty" json:"green_address,omitempty" xml:"green_address,omitempty"`
	// how much artist should get on all future resales
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// Storage fee %
	StorageFee *int `form:"storage_fee,omitempty" json:"storage_fee,omitempty" xml:"storage_fee,omitempty"`
	// nsfw score
	NsfwScore *float64 `form:"nsfw_score,omitempty" json:"nsfw_score,omitempty" xml:"nsfw_score,omitempty"`
	// pastel rareness score
	RarenessScore *float64 `form:"rareness_score,omitempty" json:"rareness_score,omitempty" xml:"rareness_score,omitempty"`
	// internet rareness score
	InternetRarenessScore *float64 `form:"internet_rareness_score,omitempty" json:"internet_rareness_score,omitempty" xml:"internet_rareness_score,omitempty"`
	// nsfw score
	DrawingNsfwScore *float64 `form:"drawing_nsfw_score,omitempty" json:"drawing_nsfw_score,omitempty" xml:"drawing_nsfw_score,omitempty"`
	// nsfw score
	NeutralNsfwScore *float64 `form:"neutral_nsfw_score,omitempty" json:"neutral_nsfw_score,omitempty" xml:"neutral_nsfw_score,omitempty"`
	// nsfw score
	SexyNsfwScore *float64 `form:"sexy_nsfw_score,omitempty" json:"sexy_nsfw_score,omitempty" xml:"sexy_nsfw_score,omitempty"`
	// nsfw score
	PornNsfwScore *float64 `form:"porn_nsfw_score,omitempty" json:"porn_nsfw_score,omitempty" xml:"porn_nsfw_score,omitempty"`
	// nsfw score
	HentaiNsfwScore *float64 `form:"hentai_nsfw_score,omitempty" json:"hentai_nsfw_score,omitempty" xml:"hentai_nsfw_score,omitempty"`
	// Thumbnail_1 image
	Thumbnail1 []byte `form:"thumbnail_1,omitempty" json:"thumbnail_1,omitempty" xml:"thumbnail_1,omitempty"`
	// Thumbnail_2 image
	Thumbnail2 []byte `form:"thumbnail_2,omitempty" json:"thumbnail_2,omitempty" xml:"thumbnail_2,omitempty"`
	// txid
	Txid *string `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	// Name of the artwork
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the artwork
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies
	Copies *int `form:"copies,omitempty" json:"copies,omitempty" xml:"copies,omitempty"`
	// Artwork creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	ArtistPastelID *string `form:"artist_pastelid,omitempty" json:"artist_pastelid,omitempty" xml:"artist_pastelid,omitempty"`
	// Name of the artist
	ArtistName *string `form:"artist_name,omitempty" json:"artist_name,omitempty" xml:"artist_name,omitempty"`
	// Artist website URL
	ArtistWebsiteURL *string `form:"artist_website_url,omitempty" json:"artist_website_url,omitempty" xml:"artist_website_url,omitempty"`
}

// DownloadResponseBody is the type of the "artworks" service "download"
// endpoint HTTP response body.
type DownloadResponseBody struct {
	// File downloaded
	File []byte `form:"file,omitempty" json:"file,omitempty" xml:"file,omitempty"`
}

// RegisterBadRequestResponseBody is the type of the "artworks" service
// "register" endpoint HTTP response body for the "BadRequest" error.
type RegisterBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterInternalServerErrorResponseBody is the type of the "artworks"
// service "register" endpoint HTTP response body for the "InternalServerError"
// error.
type RegisterInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskStateNotFoundResponseBody is the type of the "artworks" service
// "registerTaskState" endpoint HTTP response body for the "NotFound" error.
type RegisterTaskStateNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskStateInternalServerErrorResponseBody is the type of the
// "artworks" service "registerTaskState" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTaskStateInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskNotFoundResponseBody is the type of the "artworks" service
// "registerTask" endpoint HTTP response body for the "NotFound" error.
type RegisterTaskNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTaskInternalServerErrorResponseBody is the type of the "artworks"
// service "registerTask" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTaskInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RegisterTasksInternalServerErrorResponseBody is the type of the "artworks"
// service "registerTasks" endpoint HTTP response body for the
// "InternalServerError" error.
type RegisterTasksInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UploadImageBadRequestResponseBody is the type of the "artworks" service
// "uploadImage" endpoint HTTP response body for the "BadRequest" error.
type UploadImageBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// UploadImageInternalServerErrorResponseBody is the type of the "artworks"
// service "uploadImage" endpoint HTTP response body for the
// "InternalServerError" error.
type UploadImageInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ArtSearchBadRequestResponseBody is the type of the "artworks" service
// "artSearch" endpoint HTTP response body for the "BadRequest" error.
type ArtSearchBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ArtSearchInternalServerErrorResponseBody is the type of the "artworks"
// service "artSearch" endpoint HTTP response body for the
// "InternalServerError" error.
type ArtSearchInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ArtworkGetBadRequestResponseBody is the type of the "artworks" service
// "artworkGet" endpoint HTTP response body for the "BadRequest" error.
type ArtworkGetBadRequestResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ArtworkGetNotFoundResponseBody is the type of the "artworks" service
// "artworkGet" endpoint HTTP response body for the "NotFound" error.
type ArtworkGetNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ArtworkGetInternalServerErrorResponseBody is the type of the "artworks"
// service "artworkGet" endpoint HTTP response body for the
// "InternalServerError" error.
type ArtworkGetInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DownloadNotFoundResponseBody is the type of the "artworks" service
// "download" endpoint HTTP response body for the "NotFound" error.
type DownloadNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// DownloadInternalServerErrorResponseBody is the type of the "artworks"
// service "download" endpoint HTTP response body for the "InternalServerError"
// error.
type DownloadInternalServerErrorResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ThumbnailcoordinateRequestBody is used to define fields on request body
// types.
type ThumbnailcoordinateRequestBody struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX int64 `form:"top_left_x" json:"top_left_x" xml:"top_left_x"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY int64 `form:"top_left_y" json:"top_left_y" xml:"top_left_y"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX int64 `form:"bottom_right_x" json:"bottom_right_x" xml:"bottom_right_x"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY int64 `form:"bottom_right_y" json:"bottom_right_y" xml:"bottom_right_y"`
}

// TaskStateResponseBody is used to define fields on response body types.
type TaskStateResponseBody struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// ArtworkTicketResponseBody is used to define fields on response body types.
type ArtworkTicketResponseBody struct {
	// Name of the artwork
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of the artwork
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// Artwork creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	ArtistPastelID *string `form:"artist_pastelid,omitempty" json:"artist_pastelid,omitempty" xml:"artist_pastelid,omitempty"`
	// Passphrase of the artist's PastelID
	ArtistPastelIDPassphrase *string `form:"artist_pastelid_passphrase,omitempty" json:"artist_pastelid_passphrase,omitempty" xml:"artist_pastelid_passphrase,omitempty"`
	// Name of the artist
	ArtistName *string `form:"artist_name,omitempty" json:"artist_name,omitempty" xml:"artist_name,omitempty"`
	// Artist website URL
	ArtistWebsiteURL *string `form:"artist_website_url,omitempty" json:"artist_website_url,omitempty" xml:"artist_website_url,omitempty"`
	// Spendable address
	SpendableAddress *string `form:"spendable_address,omitempty" json:"spendable_address,omitempty" xml:"spendable_address,omitempty"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee *float64 `form:"maximum_fee,omitempty" json:"maximum_fee,omitempty" xml:"maximum_fee,omitempty"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                            `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateResponseBody `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
}

// ThumbnailcoordinateResponseBody is used to define fields on response body
// types.
type ThumbnailcoordinateResponseBody struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX *int64 `form:"top_left_x,omitempty" json:"top_left_x,omitempty" xml:"top_left_x,omitempty"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY *int64 `form:"top_left_y,omitempty" json:"top_left_y,omitempty" xml:"top_left_y,omitempty"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX *int64 `form:"bottom_right_x,omitempty" json:"bottom_right_x,omitempty" xml:"bottom_right_x,omitempty"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY *int64 `form:"bottom_right_y,omitempty" json:"bottom_right_y,omitempty" xml:"bottom_right_y,omitempty"`
}

// TaskResponse is used to define fields on response body types.
type TaskResponse struct {
	// JOb ID of the registration process
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// List of states from the very beginning of the process
	States []*TaskStateResponse `form:"states,omitempty" json:"states,omitempty" xml:"states,omitempty"`
	// txid
	Txid   *string                `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	Ticket *ArtworkTicketResponse `form:"ticket,omitempty" json:"ticket,omitempty" xml:"ticket,omitempty"`
}

// TaskStateResponse is used to define fields on response body types.
type TaskStateResponse struct {
	// Date of the status creation
	Date *string `form:"date,omitempty" json:"date,omitempty" xml:"date,omitempty"`
	// Status of the registration process
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// ArtworkTicketResponse is used to define fields on response body types.
type ArtworkTicketResponse struct {
	// Name of the artwork
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Description of the artwork
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies issued
	IssuedCopies *int `form:"issued_copies,omitempty" json:"issued_copies,omitempty" xml:"issued_copies,omitempty"`
	// Artwork creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	ArtistPastelID *string `form:"artist_pastelid,omitempty" json:"artist_pastelid,omitempty" xml:"artist_pastelid,omitempty"`
	// Passphrase of the artist's PastelID
	ArtistPastelIDPassphrase *string `form:"artist_pastelid_passphrase,omitempty" json:"artist_pastelid_passphrase,omitempty" xml:"artist_pastelid_passphrase,omitempty"`
	// Name of the artist
	ArtistName *string `form:"artist_name,omitempty" json:"artist_name,omitempty" xml:"artist_name,omitempty"`
	// Artist website URL
	ArtistWebsiteURL *string `form:"artist_website_url,omitempty" json:"artist_website_url,omitempty" xml:"artist_website_url,omitempty"`
	// Spendable address
	SpendableAddress *string `form:"spendable_address,omitempty" json:"spendable_address,omitempty" xml:"spendable_address,omitempty"`
	// Used to find a suitable masternode with a fee equal or less
	MaximumFee *float64 `form:"maximum_fee,omitempty" json:"maximum_fee,omitempty" xml:"maximum_fee,omitempty"`
	// Percentage the artist received in future sales. If set to 0% he only get
	// paids for the first sale on each copy of the NFT
	Royalty *float64 `form:"royalty,omitempty" json:"royalty,omitempty" xml:"royalty,omitempty"`
	// To donate 2% of the sale proceeds on every sale to TeamTrees which plants
	// trees
	Green               *bool                        `form:"green,omitempty" json:"green,omitempty" xml:"green,omitempty"`
	ThumbnailCoordinate *ThumbnailcoordinateResponse `form:"thumbnail_coordinate,omitempty" json:"thumbnail_coordinate,omitempty" xml:"thumbnail_coordinate,omitempty"`
}

// ThumbnailcoordinateResponse is used to define fields on response body types.
type ThumbnailcoordinateResponse struct {
	// X coordinate of the thumbnail's top left conner
	TopLeftX *int64 `form:"top_left_x,omitempty" json:"top_left_x,omitempty" xml:"top_left_x,omitempty"`
	// Y coordinate of the thumbnail's top left conner
	TopLeftY *int64 `form:"top_left_y,omitempty" json:"top_left_y,omitempty" xml:"top_left_y,omitempty"`
	// X coordinate of the thumbnail's bottom right conner
	BottomRightX *int64 `form:"bottom_right_x,omitempty" json:"bottom_right_x,omitempty" xml:"bottom_right_x,omitempty"`
	// Y coordinate of the thumbnail's bottom right conner
	BottomRightY *int64 `form:"bottom_right_y,omitempty" json:"bottom_right_y,omitempty" xml:"bottom_right_y,omitempty"`
}

// ArtworkSummaryResponseBody is used to define fields on response body types.
type ArtworkSummaryResponseBody struct {
	// Thumbnail_1 image
	Thumbnail1 []byte `form:"thumbnail_1,omitempty" json:"thumbnail_1,omitempty" xml:"thumbnail_1,omitempty"`
	// Thumbnail_2 image
	Thumbnail2 []byte `form:"thumbnail_2,omitempty" json:"thumbnail_2,omitempty" xml:"thumbnail_2,omitempty"`
	// txid
	Txid *string `form:"txid,omitempty" json:"txid,omitempty" xml:"txid,omitempty"`
	// Name of the artwork
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Description of the artwork
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Keywords
	Keywords *string `form:"keywords,omitempty" json:"keywords,omitempty" xml:"keywords,omitempty"`
	// Series name
	SeriesName *string `form:"series_name,omitempty" json:"series_name,omitempty" xml:"series_name,omitempty"`
	// Number of copies
	Copies *int `form:"copies,omitempty" json:"copies,omitempty" xml:"copies,omitempty"`
	// Artwork creation video youtube URL
	YoutubeURL *string `form:"youtube_url,omitempty" json:"youtube_url,omitempty" xml:"youtube_url,omitempty"`
	// Artist's PastelID
	ArtistPastelID *string `form:"artist_pastelid,omitempty" json:"artist_pastelid,omitempty" xml:"artist_pastelid,omitempty"`
	// Name of the artist
	ArtistName *string `form:"artist_name,omitempty" json:"artist_name,omitempty" xml:"artist_name,omitempty"`
	// Artist website URL
	ArtistWebsiteURL *string `form:"artist_website_url,omitempty" json:"artist_website_url,omitempty" xml:"artist_website_url,omitempty"`
}

// FuzzyMatchResponseBody is used to define fields on response body types.
type FuzzyMatchResponseBody struct {
	// String that is matched
	Str *string `form:"str,omitempty" json:"str,omitempty" xml:"str,omitempty"`
	// Field that is matched
	FieldType *string `form:"field_type,omitempty" json:"field_type,omitempty" xml:"field_type,omitempty"`
	// The indexes of matched characters. Useful for highlighting matches
	MatchedIndexes []int `form:"matched_indexes,omitempty" json:"matched_indexes,omitempty" xml:"matched_indexes,omitempty"`
	// Score used to rank matches
	Score *int `form:"score,omitempty" json:"score,omitempty" xml:"score,omitempty"`
}

// NewRegisterRequestBody builds the HTTP request body from the payload of the
// "register" endpoint of the "artworks" service.
func NewRegisterRequestBody(p *artworks.RegisterPayload) *RegisterRequestBody {
	body := &RegisterRequestBody{
		ImageID:                  p.ImageID,
		Name:                     p.Name,
		Description:              p.Description,
		Keywords:                 p.Keywords,
		SeriesName:               p.SeriesName,
		IssuedCopies:             p.IssuedCopies,
		YoutubeURL:               p.YoutubeURL,
		ArtistPastelID:           p.ArtistPastelID,
		ArtistPastelIDPassphrase: p.ArtistPastelIDPassphrase,
		ArtistName:               p.ArtistName,
		ArtistWebsiteURL:         p.ArtistWebsiteURL,
		SpendableAddress:         p.SpendableAddress,
		MaximumFee:               p.MaximumFee,
		Royalty:                  p.Royalty,
		Green:                    p.Green,
	}
	{
		var zero float64
		if body.Royalty == zero {
			body.Royalty = 0
		}
	}
	{
		var zero bool
		if body.Green == zero {
			body.Green = false
		}
	}
	if p.ThumbnailCoordinate != nil {
		body.ThumbnailCoordinate = marshalArtworksThumbnailcoordinateToThumbnailcoordinateRequestBody(p.ThumbnailCoordinate)
	}
	return body
}

// NewUploadImageRequestBody builds the HTTP request body from the payload of
// the "uploadImage" endpoint of the "artworks" service.
func NewUploadImageRequestBody(p *artworks.UploadImagePayload) *UploadImageRequestBody {
	body := &UploadImageRequestBody{
		Bytes:    p.Bytes,
		Filename: p.Filename,
	}
	return body
}

// NewRegisterResultViewCreated builds a "artworks" service "register" endpoint
// result from a HTTP "Created" response.
func NewRegisterResultViewCreated(body *RegisterResponseBody) *artworksviews.RegisterResultView {
	v := &artworksviews.RegisterResultView{
		TaskID: body.TaskID,
	}

	return v
}

// NewRegisterBadRequest builds a artworks service register endpoint BadRequest
// error.
func NewRegisterBadRequest(body *RegisterBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterInternalServerError builds a artworks service register endpoint
// InternalServerError error.
func NewRegisterInternalServerError(body *RegisterInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskStateTaskStateOK builds a "artworks" service
// "registerTaskState" endpoint result from a HTTP "OK" response.
func NewRegisterTaskStateTaskStateOK(body *RegisterTaskStateResponseBody) *artworks.TaskState {
	v := &artworks.TaskState{
		Date:   *body.Date,
		Status: *body.Status,
	}

	return v
}

// NewRegisterTaskStateNotFound builds a artworks service registerTaskState
// endpoint NotFound error.
func NewRegisterTaskStateNotFound(body *RegisterTaskStateNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskStateInternalServerError builds a artworks service
// registerTaskState endpoint InternalServerError error.
func NewRegisterTaskStateInternalServerError(body *RegisterTaskStateInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskTaskOK builds a "artworks" service "registerTask" endpoint
// result from a HTTP "OK" response.
func NewRegisterTaskTaskOK(body *RegisterTaskResponseBody) *artworksviews.TaskView {
	v := &artworksviews.TaskView{
		ID:     body.ID,
		Status: body.Status,
		Txid:   body.Txid,
	}
	if body.States != nil {
		v.States = make([]*artworksviews.TaskStateView, len(body.States))
		for i, val := range body.States {
			v.States[i] = unmarshalTaskStateResponseBodyToArtworksviewsTaskStateView(val)
		}
	}
	v.Ticket = unmarshalArtworkTicketResponseBodyToArtworksviewsArtworkTicketView(body.Ticket)

	return v
}

// NewRegisterTaskNotFound builds a artworks service registerTask endpoint
// NotFound error.
func NewRegisterTaskNotFound(body *RegisterTaskNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTaskInternalServerError builds a artworks service registerTask
// endpoint InternalServerError error.
func NewRegisterTaskInternalServerError(body *RegisterTaskInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRegisterTasksTaskCollectionOK builds a "artworks" service "registerTasks"
// endpoint result from a HTTP "OK" response.
func NewRegisterTasksTaskCollectionOK(body RegisterTasksResponseBody) artworksviews.TaskCollectionView {
	v := make([]*artworksviews.TaskView, len(body))
	for i, val := range body {
		v[i] = unmarshalTaskResponseToArtworksviewsTaskView(val)
	}

	return v
}

// NewRegisterTasksInternalServerError builds a artworks service registerTasks
// endpoint InternalServerError error.
func NewRegisterTasksInternalServerError(body *RegisterTasksInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUploadImageImageCreated builds a "artworks" service "uploadImage"
// endpoint result from a HTTP "Created" response.
func NewUploadImageImageCreated(body *UploadImageResponseBody) *artworksviews.ImageView {
	v := &artworksviews.ImageView{
		ImageID:   body.ImageID,
		ExpiresIn: body.ExpiresIn,
	}

	return v
}

// NewUploadImageBadRequest builds a artworks service uploadImage endpoint
// BadRequest error.
func NewUploadImageBadRequest(body *UploadImageBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewUploadImageInternalServerError builds a artworks service uploadImage
// endpoint InternalServerError error.
func NewUploadImageInternalServerError(body *UploadImageInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewArtSearchArtworkSearchResultOK builds a "artworks" service "artSearch"
// endpoint result from a HTTP "OK" response.
func NewArtSearchArtworkSearchResultOK(body *ArtSearchResponseBody) *artworks.ArtworkSearchResult {
	v := &artworks.ArtworkSearchResult{
		MatchIndex: *body.MatchIndex,
	}
	v.Artwork = unmarshalArtworkSummaryResponseBodyToArtworksArtworkSummary(body.Artwork)
	v.Matches = make([]*artworks.FuzzyMatch, len(body.Matches))
	for i, val := range body.Matches {
		v.Matches[i] = unmarshalFuzzyMatchResponseBodyToArtworksFuzzyMatch(val)
	}

	return v
}

// NewArtSearchBadRequest builds a artworks service artSearch endpoint
// BadRequest error.
func NewArtSearchBadRequest(body *ArtSearchBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewArtSearchInternalServerError builds a artworks service artSearch endpoint
// InternalServerError error.
func NewArtSearchInternalServerError(body *ArtSearchInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewArtworkGetArtworkDetailOK builds a "artworks" service "artworkGet"
// endpoint result from a HTTP "OK" response.
func NewArtworkGetArtworkDetailOK(body *ArtworkGetResponseBody) *artworks.ArtworkDetail {
	v := &artworks.ArtworkDetail{
		Version:               body.Version,
		GreenAddress:          body.GreenAddress,
		Royalty:               body.Royalty,
		StorageFee:            body.StorageFee,
		NsfwScore:             *body.NsfwScore,
		RarenessScore:         *body.RarenessScore,
		InternetRarenessScore: body.InternetRarenessScore,
		DrawingNsfwScore:      body.DrawingNsfwScore,
		NeutralNsfwScore:      body.NeutralNsfwScore,
		SexyNsfwScore:         body.SexyNsfwScore,
		PornNsfwScore:         body.PornNsfwScore,
		HentaiNsfwScore:       body.HentaiNsfwScore,
		Thumbnail1:            body.Thumbnail1,
		Thumbnail2:            body.Thumbnail2,
		Txid:                  *body.Txid,
		Title:                 *body.Title,
		Description:           *body.Description,
		Keywords:              body.Keywords,
		SeriesName:            body.SeriesName,
		Copies:                *body.Copies,
		YoutubeURL:            body.YoutubeURL,
		ArtistPastelID:        *body.ArtistPastelID,
		ArtistName:            *body.ArtistName,
		ArtistWebsiteURL:      body.ArtistWebsiteURL,
	}

	return v
}

// NewArtworkGetBadRequest builds a artworks service artworkGet endpoint
// BadRequest error.
func NewArtworkGetBadRequest(body *ArtworkGetBadRequestResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewArtworkGetNotFound builds a artworks service artworkGet endpoint NotFound
// error.
func NewArtworkGetNotFound(body *ArtworkGetNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewArtworkGetInternalServerError builds a artworks service artworkGet
// endpoint InternalServerError error.
func NewArtworkGetInternalServerError(body *ArtworkGetInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDownloadResultOK builds a "artworks" service "download" endpoint result
// from a HTTP "OK" response.
func NewDownloadResultOK(body *DownloadResponseBody) *artworks.DownloadResult {
	v := &artworks.DownloadResult{
		File: body.File,
	}

	return v
}

// NewDownloadNotFound builds a artworks service download endpoint NotFound
// error.
func NewDownloadNotFound(body *DownloadNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewDownloadInternalServerError builds a artworks service download endpoint
// InternalServerError error.
func NewDownloadInternalServerError(body *DownloadInternalServerErrorResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// ValidateRegisterTaskStateResponseBody runs the validations defined on
// RegisterTaskStateResponseBody
func ValidateRegisterTaskStateResponseBody(body *RegisterTaskStateResponseBody) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Ticket Accepted" || *body.Status == "Ticket Registered" || *body.Status == "Ticket Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Ticket Accepted", "Ticket Registered", "Ticket Activated", "Error Insufficient Fee", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateArtSearchResponseBody runs the validations defined on
// ArtSearchResponseBody
func ValidateArtSearchResponseBody(body *ArtSearchResponseBody) (err error) {
	if body.Artwork == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artwork", "body"))
	}
	if body.Matches == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("matches", "body"))
	}
	if body.MatchIndex == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("match_index", "body"))
	}
	if body.Artwork != nil {
		if err2 := ValidateArtworkSummaryResponseBody(body.Artwork); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Matches {
		if e != nil {
			if err2 := ValidateFuzzyMatchResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateArtworkGetResponseBody runs the validations defined on
// ArtworkGetResponseBody
func ValidateArtworkGetResponseBody(body *ArtworkGetResponseBody) (err error) {
	if body.RarenessScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("rareness_score", "body"))
	}
	if body.NsfwScore == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("nsfw_score", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.ArtistName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_name", "body"))
	}
	if body.Copies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("copies", "body"))
	}
	if body.ArtistPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_pastelid", "body"))
	}
	if body.Txid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txid", "body"))
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 0, true))
		}
	}
	if body.NsfwScore != nil {
		if *body.NsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.nsfw_score", *body.NsfwScore, 1, false))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 0, true))
		}
	}
	if body.RarenessScore != nil {
		if *body.RarenessScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.rareness_score", *body.RarenessScore, 1, false))
		}
	}
	if body.InternetRarenessScore != nil {
		if *body.InternetRarenessScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.internet_rareness_score", *body.InternetRarenessScore, 0, true))
		}
	}
	if body.InternetRarenessScore != nil {
		if *body.InternetRarenessScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.internet_rareness_score", *body.InternetRarenessScore, 1, false))
		}
	}
	if body.DrawingNsfwScore != nil {
		if *body.DrawingNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.drawing_nsfw_score", *body.DrawingNsfwScore, 0, true))
		}
	}
	if body.DrawingNsfwScore != nil {
		if *body.DrawingNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.drawing_nsfw_score", *body.DrawingNsfwScore, 1, false))
		}
	}
	if body.NeutralNsfwScore != nil {
		if *body.NeutralNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.neutral_nsfw_score", *body.NeutralNsfwScore, 0, true))
		}
	}
	if body.NeutralNsfwScore != nil {
		if *body.NeutralNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.neutral_nsfw_score", *body.NeutralNsfwScore, 1, false))
		}
	}
	if body.SexyNsfwScore != nil {
		if *body.SexyNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.sexy_nsfw_score", *body.SexyNsfwScore, 0, true))
		}
	}
	if body.SexyNsfwScore != nil {
		if *body.SexyNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.sexy_nsfw_score", *body.SexyNsfwScore, 1, false))
		}
	}
	if body.PornNsfwScore != nil {
		if *body.PornNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.porn_nsfw_score", *body.PornNsfwScore, 0, true))
		}
	}
	if body.PornNsfwScore != nil {
		if *body.PornNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.porn_nsfw_score", *body.PornNsfwScore, 1, false))
		}
	}
	if body.HentaiNsfwScore != nil {
		if *body.HentaiNsfwScore < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hentai_nsfw_score", *body.HentaiNsfwScore, 0, true))
		}
	}
	if body.HentaiNsfwScore != nil {
		if *body.HentaiNsfwScore > 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.hentai_nsfw_score", *body.HentaiNsfwScore, 1, false))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.Copies != nil {
		if *body.Copies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1, true))
		}
	}
	if body.Copies != nil {
		if *body.Copies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.ArtistPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.artist_pastelid", *body.ArtistPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, true))
		}
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, false))
		}
	}
	if body.ArtistName != nil {
		if utf8.RuneCountInString(*body.ArtistName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_name", *body.ArtistName, utf8.RuneCountInString(*body.ArtistName), 256, false))
		}
	}
	if body.ArtistWebsiteURL != nil {
		if utf8.RuneCountInString(*body.ArtistWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_website_url", *body.ArtistWebsiteURL, utf8.RuneCountInString(*body.ArtistWebsiteURL), 256, false))
		}
	}
	return
}

// ValidateDownloadResponseBody runs the validations defined on
// DownloadResponseBody
func ValidateDownloadResponseBody(body *DownloadResponseBody) (err error) {
	if body.File == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("file", "body"))
	}
	return
}

// ValidateRegisterBadRequestResponseBody runs the validations defined on
// register_BadRequest_response_body
func ValidateRegisterBadRequestResponseBody(body *RegisterBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterInternalServerErrorResponseBody runs the validations defined
// on register_InternalServerError_response_body
func ValidateRegisterInternalServerErrorResponseBody(body *RegisterInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskStateNotFoundResponseBody runs the validations defined
// on registerTaskState_NotFound_response_body
func ValidateRegisterTaskStateNotFoundResponseBody(body *RegisterTaskStateNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskStateInternalServerErrorResponseBody runs the
// validations defined on registerTaskState_InternalServerError_response_body
func ValidateRegisterTaskStateInternalServerErrorResponseBody(body *RegisterTaskStateInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskNotFoundResponseBody runs the validations defined on
// registerTask_NotFound_response_body
func ValidateRegisterTaskNotFoundResponseBody(body *RegisterTaskNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTaskInternalServerErrorResponseBody runs the validations
// defined on registerTask_InternalServerError_response_body
func ValidateRegisterTaskInternalServerErrorResponseBody(body *RegisterTaskInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRegisterTasksInternalServerErrorResponseBody runs the validations
// defined on registerTasks_InternalServerError_response_body
func ValidateRegisterTasksInternalServerErrorResponseBody(body *RegisterTasksInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUploadImageBadRequestResponseBody runs the validations defined on
// uploadImage_BadRequest_response_body
func ValidateUploadImageBadRequestResponseBody(body *UploadImageBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateUploadImageInternalServerErrorResponseBody runs the validations
// defined on uploadImage_InternalServerError_response_body
func ValidateUploadImageInternalServerErrorResponseBody(body *UploadImageInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateArtSearchBadRequestResponseBody runs the validations defined on
// artSearch_BadRequest_response_body
func ValidateArtSearchBadRequestResponseBody(body *ArtSearchBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateArtSearchInternalServerErrorResponseBody runs the validations
// defined on artSearch_InternalServerError_response_body
func ValidateArtSearchInternalServerErrorResponseBody(body *ArtSearchInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateArtworkGetBadRequestResponseBody runs the validations defined on
// artworkGet_BadRequest_response_body
func ValidateArtworkGetBadRequestResponseBody(body *ArtworkGetBadRequestResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateArtworkGetNotFoundResponseBody runs the validations defined on
// artworkGet_NotFound_response_body
func ValidateArtworkGetNotFoundResponseBody(body *ArtworkGetNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateArtworkGetInternalServerErrorResponseBody runs the validations
// defined on artworkGet_InternalServerError_response_body
func ValidateArtworkGetInternalServerErrorResponseBody(body *ArtworkGetInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDownloadNotFoundResponseBody runs the validations defined on
// download_NotFound_response_body
func ValidateDownloadNotFoundResponseBody(body *DownloadNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateDownloadInternalServerErrorResponseBody runs the validations defined
// on download_InternalServerError_response_body
func ValidateDownloadInternalServerErrorResponseBody(body *DownloadInternalServerErrorResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateTaskStateResponseBody runs the validations defined on
// TaskStateResponseBody
func ValidateTaskStateResponseBody(body *TaskStateResponseBody) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Ticket Accepted" || *body.Status == "Ticket Registered" || *body.Status == "Ticket Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Ticket Accepted", "Ticket Registered", "Ticket Activated", "Error Insufficient Fee", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateArtworkTicketResponseBody runs the validations defined on
// ArtworkTicketResponseBody
func ValidateArtworkTicketResponseBody(body *ArtworkTicketResponseBody) (err error) {
	if body.ArtistName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_name", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.IssuedCopies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("issued_copies", "body"))
	}
	if body.ArtistPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_pastelid", "body"))
	}
	if body.ArtistPastelIDPassphrase == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_pastelid_passphrase", "body"))
	}
	if body.SpendableAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spendable_address", "body"))
	}
	if body.MaximumFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("maximum_fee", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1, true))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.ArtistPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.artist_pastelid", *body.ArtistPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, true))
		}
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, false))
		}
	}
	if body.ArtistName != nil {
		if utf8.RuneCountInString(*body.ArtistName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_name", *body.ArtistName, utf8.RuneCountInString(*body.ArtistName), 256, false))
		}
	}
	if body.ArtistWebsiteURL != nil {
		if utf8.RuneCountInString(*body.ArtistWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_website_url", *body.ArtistWebsiteURL, utf8.RuneCountInString(*body.ArtistWebsiteURL), 256, false))
		}
	}
	if body.SpendableAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spendable_address", *body.SpendableAddress, "^[a-zA-Z0-9]+$"))
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) < 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, true))
		}
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) > 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, false))
		}
	}
	if body.MaximumFee != nil {
		if *body.MaximumFee < 1e-05 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.maximum_fee", *body.MaximumFee, 1e-05, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 0, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 100, false))
		}
	}
	if body.ThumbnailCoordinate != nil {
		if err2 := ValidateThumbnailcoordinateResponseBody(body.ThumbnailCoordinate); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateThumbnailcoordinateResponseBody runs the validations defined on
// ThumbnailcoordinateResponseBody
func ValidateThumbnailcoordinateResponseBody(body *ThumbnailcoordinateResponseBody) (err error) {
	if body.TopLeftX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_x", "body"))
	}
	if body.TopLeftY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_y", "body"))
	}
	if body.BottomRightX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_x", "body"))
	}
	if body.BottomRightY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_y", "body"))
	}
	return
}

// ValidateTaskResponse runs the validations defined on TaskResponse
func ValidateTaskResponse(body *TaskResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Ticket == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("ticket", "body"))
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) < 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 8, true))
		}
	}
	if body.ID != nil {
		if utf8.RuneCountInString(*body.ID) > 8 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.id", *body.ID, utf8.RuneCountInString(*body.ID), 8, false))
		}
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Ticket Accepted" || *body.Status == "Ticket Registered" || *body.Status == "Ticket Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Ticket Accepted", "Ticket Registered", "Ticket Activated", "Error Insufficient Fee", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Task Rejected", "Task Completed"}))
		}
	}
	for _, e := range body.States {
		if e != nil {
			if err2 := ValidateTaskStateResponse(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Ticket != nil {
		if err2 := ValidateArtworkTicketResponse(body.Ticket); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateTaskStateResponse runs the validations defined on TaskStateResponse
func ValidateTaskStateResponse(body *TaskStateResponse) (err error) {
	if body.Date == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("date", "body"))
	}
	if body.Status == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("status", "body"))
	}
	if body.Status != nil {
		if !(*body.Status == "Task Started" || *body.Status == "Connected" || *body.Status == "Image Probed" || *body.Status == "Image And Thumbnail Uploaded" || *body.Status == "Status Gen ReptorQ Symbols" || *body.Status == "Preburn Registration Fee" || *body.Status == "Ticket Accepted" || *body.Status == "Ticket Registered" || *body.Status == "Ticket Activated" || *body.Status == "Error Insufficient Fee" || *body.Status == "Error Fingerprints Dont Match" || *body.Status == "Error ThumbnailHashes Dont Match" || *body.Status == "Error GenRaptorQ Symbols Failed" || *body.Status == "Task Rejected" || *body.Status == "Task Completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"Task Started", "Connected", "Image Probed", "Image And Thumbnail Uploaded", "Status Gen ReptorQ Symbols", "Preburn Registration Fee", "Ticket Accepted", "Ticket Registered", "Ticket Activated", "Error Insufficient Fee", "Error Fingerprints Dont Match", "Error ThumbnailHashes Dont Match", "Error GenRaptorQ Symbols Failed", "Task Rejected", "Task Completed"}))
		}
	}
	return
}

// ValidateArtworkTicketResponse runs the validations defined on
// ArtworkTicketResponse
func ValidateArtworkTicketResponse(body *ArtworkTicketResponse) (err error) {
	if body.ArtistName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_name", "body"))
	}
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.IssuedCopies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("issued_copies", "body"))
	}
	if body.ArtistPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_pastelid", "body"))
	}
	if body.ArtistPastelIDPassphrase == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_pastelid_passphrase", "body"))
	}
	if body.SpendableAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("spendable_address", "body"))
	}
	if body.MaximumFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("maximum_fee", "body"))
	}
	if body.Name != nil {
		if utf8.RuneCountInString(*body.Name) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", *body.Name, utf8.RuneCountInString(*body.Name), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1, true))
		}
	}
	if body.IssuedCopies != nil {
		if *body.IssuedCopies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.issued_copies", *body.IssuedCopies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.ArtistPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.artist_pastelid", *body.ArtistPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, true))
		}
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, false))
		}
	}
	if body.ArtistName != nil {
		if utf8.RuneCountInString(*body.ArtistName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_name", *body.ArtistName, utf8.RuneCountInString(*body.ArtistName), 256, false))
		}
	}
	if body.ArtistWebsiteURL != nil {
		if utf8.RuneCountInString(*body.ArtistWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_website_url", *body.ArtistWebsiteURL, utf8.RuneCountInString(*body.ArtistWebsiteURL), 256, false))
		}
	}
	if body.SpendableAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.spendable_address", *body.SpendableAddress, "^[a-zA-Z0-9]+$"))
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) < 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, true))
		}
	}
	if body.SpendableAddress != nil {
		if utf8.RuneCountInString(*body.SpendableAddress) > 35 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.spendable_address", *body.SpendableAddress, utf8.RuneCountInString(*body.SpendableAddress), 35, false))
		}
	}
	if body.MaximumFee != nil {
		if *body.MaximumFee < 1e-05 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.maximum_fee", *body.MaximumFee, 1e-05, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 0, true))
		}
	}
	if body.Royalty != nil {
		if *body.Royalty > 100 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.royalty", *body.Royalty, 100, false))
		}
	}
	if body.ThumbnailCoordinate != nil {
		if err2 := ValidateThumbnailcoordinateResponse(body.ThumbnailCoordinate); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateThumbnailcoordinateResponse runs the validations defined on
// ThumbnailcoordinateResponse
func ValidateThumbnailcoordinateResponse(body *ThumbnailcoordinateResponse) (err error) {
	if body.TopLeftX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_x", "body"))
	}
	if body.TopLeftY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("top_left_y", "body"))
	}
	if body.BottomRightX == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_x", "body"))
	}
	if body.BottomRightY == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("bottom_right_y", "body"))
	}
	return
}

// ValidateArtworkSummaryResponseBody runs the validations defined on
// ArtworkSummaryResponseBody
func ValidateArtworkSummaryResponseBody(body *ArtworkSummaryResponseBody) (err error) {
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.ArtistName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_name", "body"))
	}
	if body.Copies == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("copies", "body"))
	}
	if body.ArtistPastelID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("artist_pastelid", "body"))
	}
	if body.Txid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txid", "body"))
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) < 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, true))
		}
	}
	if body.Txid != nil {
		if utf8.RuneCountInString(*body.Txid) > 64 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txid", *body.Txid, utf8.RuneCountInString(*body.Txid), 64, false))
		}
	}
	if body.Title != nil {
		if utf8.RuneCountInString(*body.Title) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.title", *body.Title, utf8.RuneCountInString(*body.Title), 256, false))
		}
	}
	if body.Description != nil {
		if utf8.RuneCountInString(*body.Description) > 1024 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 1024, false))
		}
	}
	if body.Keywords != nil {
		if utf8.RuneCountInString(*body.Keywords) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.keywords", *body.Keywords, utf8.RuneCountInString(*body.Keywords), 256, false))
		}
	}
	if body.SeriesName != nil {
		if utf8.RuneCountInString(*body.SeriesName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.series_name", *body.SeriesName, utf8.RuneCountInString(*body.SeriesName), 256, false))
		}
	}
	if body.Copies != nil {
		if *body.Copies < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1, true))
		}
	}
	if body.Copies != nil {
		if *body.Copies > 1000 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.copies", *body.Copies, 1000, false))
		}
	}
	if body.YoutubeURL != nil {
		if utf8.RuneCountInString(*body.YoutubeURL) > 128 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.youtube_url", *body.YoutubeURL, utf8.RuneCountInString(*body.YoutubeURL), 128, false))
		}
	}
	if body.ArtistPastelID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.artist_pastelid", *body.ArtistPastelID, "^[a-zA-Z0-9]+$"))
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) < 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, true))
		}
	}
	if body.ArtistPastelID != nil {
		if utf8.RuneCountInString(*body.ArtistPastelID) > 86 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_pastelid", *body.ArtistPastelID, utf8.RuneCountInString(*body.ArtistPastelID), 86, false))
		}
	}
	if body.ArtistName != nil {
		if utf8.RuneCountInString(*body.ArtistName) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_name", *body.ArtistName, utf8.RuneCountInString(*body.ArtistName), 256, false))
		}
	}
	if body.ArtistWebsiteURL != nil {
		if utf8.RuneCountInString(*body.ArtistWebsiteURL) > 256 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.artist_website_url", *body.ArtistWebsiteURL, utf8.RuneCountInString(*body.ArtistWebsiteURL), 256, false))
		}
	}
	return
}

// ValidateFuzzyMatchResponseBody runs the validations defined on
// FuzzyMatchResponseBody
func ValidateFuzzyMatchResponseBody(body *FuzzyMatchResponseBody) (err error) {
	if body.FieldType != nil {
		if !(*body.FieldType == "artist_name" || *body.FieldType == "art_title" || *body.FieldType == "series" || *body.FieldType == "descr" || *body.FieldType == "keyword") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.field_type", *body.FieldType, []interface{}{"artist_name", "art_title", "series", "descr", "keyword"}))
		}
	}
	return
}
